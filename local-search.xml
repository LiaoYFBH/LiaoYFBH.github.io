<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>K-means算法学习笔记</title>
    <link href="/2024/11/28/Kmeans%E7%AE%97%E6%B3%95/"/>
    <url>/2024/11/28/Kmeans%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>本文为K-means算法的学习笔记</p><span id="more"></span><h2 id="k-means算法">K-means算法</h2><p>无监督学习、聚类</p><p>将数据集中的<span class="math inline">\(n\)</span>个数据点分为<spanclass="math inline">\(K\)</span>个clusters(簇)，同一个簇中的数据点之间尽量相似，不同簇之间的数据点尽量不同</p><h3 id="损失函数cost-function">损失函数(cost function)</h3><p><span class="math display">\[J=\sum_{i=1}^K \sum_{x\in C_i} \Vert x-\mu_i\Vert^2\]</span></p><p>其中<span class="math inline">\(C_i\)</span>代表第<spanclass="math inline">\(i\)</span>个簇的数据点集,<spanclass="math inline">\(\mu_i\)</span>代表第<spanclass="math inline">\(i\)</span>个簇中心。</p><p>最小化每个簇内的距离平方误差和。</p><h3 id="算法流程">算法流程</h3><table><thead><tr class="header"><th></th><th>K-means算法流程</th></tr></thead><tbody><tr class="odd"><td></td><td>选择距离度量方法和<span class="math inline">\(K\)</span>值</td></tr><tr class="even"><td>1、初始化簇中心</td><td>随机选择<spanclass="math inline">\(K\)</span>个数据点为初始簇中心</td></tr><tr class="odd"><td>2</td><td>计算所有样本点到每个中心点的距离，并将样本点划分给离其最近的中心。</td></tr><tr class="even"><td>3</td><td>计算新的簇中样本点的平均值，将其作为新的簇中心</td></tr><tr class="odd"><td>4</td><td>迭代2和3，直到达到迭代终止的条件(满足以下任一)：<br />(1)迭代次数达到了预先设置的最大迭代次数<br />(2)簇中心不再发生变化或变化小于预先设置的阈值</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习，聚类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KNN(k-Nearest Neighbor，K近邻)学习笔记</title>
    <link href="/2024/11/28/KNN%E7%AE%97%E6%B3%95/"/>
    <url>/2024/11/28/KNN%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>本文为KNN算法的学习笔记</p><span id="more"></span><h2 id="knnk-nearest-neighbork近邻">KNN(k-Nearest Neighbor，K近邻)</h2><p>监督学习、lazy learning</p><p>给定测试样本，基于某种距离度量找出训练集中与其最靠近的<spanclass="math inline">\(k\)</span>个样本，然后进行相应处理得到预测结果。</p><h3 id="距离度量标准">距离度量标准</h3><table><thead><tr class="header"><th>名称</th><th>公式</th><th>概况</th><th>是否常用</th></tr></thead><tbody><tr class="odd"><td>欧氏距离</td><td><spanclass="math inline">\(d=\sqrt{\sum_{k=1}^{n}(x_{1k}-x_{2k})^2}\)</span>，两个<spanclass="math inline">\(n\)</span>维向量之间的欧氏距离</td><td>简易理解为两点之间的直线距离</td><td>更常用</td></tr><tr class="even"><td>曼哈顿距离</td><td><spanclass="math inline">\(d=|x_{1k}-x_{2k}|+\dots|x_{1n}-x_{2n}|\)</span>，两个<spanclass="math inline">\(n\)</span>维向量之间的曼哈顿距离</td><td>简易理解为两个点之间的网格距离</td><td></td></tr><tr class="odd"><td>Lp距离</td><td><span class="math inline">\(d=[\sum_{k=1}^{n}\vert x_{1k}-x_{2k}\vert^p]^{1/p}\)</span>，当<spanclass="math inline">\(p=1\)</span>，为曼哈顿距离；当<spanclass="math inline">\(p=2\)</span>时，为欧氏距离</td><td></td><td></td></tr></tbody></table><h3 id="k值选取"><span class="math inline">\(k\)</span>值选取</h3><h4 id="k折交叉验证法"><spanclass="math inline">\(k\)</span>折交叉验证法</h4><ul><li>将数据集分为训练集(大部分)和测试集(小部分)</li><li>将训练集分为<spanclass="math inline">\(k\)</span>个互不相交、大小相同的子集，进行<spanclass="math inline">\(k\)</span>次KNN模型，每次选择其中1个子集作为验证集，其余<spanclass="math inline">\(k-1\)</span>个子集为训练集。</li><li>选择要设置的<spanclass="math inline">\(k\)</span>值范围，从最小值开始，每次以固定值增加。每次迭代计算准确率。</li><li>选择上述准确率最高的<span class="math inline">\(k\)</span>值</li></ul><h3 id="用于分类">用于分类</h3><p>对象的分类由其最相邻的<spanclass="math inline">\(k\)</span>个最近邻居中最常见的分类决定</p><h3 id="用于回归">用于回归</h3><p>输出值是其<spanclass="math inline">\(k\)</span>个最近邻居值的平均值或加权平均值</p><h3 id="算法流程">算法流程</h3><table><thead><tr class="header"><th></th><th>KNN算法流程</th></tr></thead><tbody><tr class="odd"><td>需要提前设置的</td><td>1、选用距离类型<br />2、选择<spanclass="math inline">\(k\)</span>值<br />3、可对不同取值范围特征值进行归一化</td></tr><tr class="even"><td></td><td>计算测试数据和每个训练数据之间的距离</td></tr><tr class="odd"><td></td><td>对上述计算的距离进行排序</td></tr><tr class="even"><td></td><td>选择最近的<span class="math inline">\(k\)</span>个点</td></tr><tr class="odd"><td></td><td>分类：统计这<spanclass="math inline">\(k\)</span>个点类别出现的频率，频率最高的类别为测试样本的预测分类<br />回归：计算着<spanclass="math inline">\(k\)</span>个点的均值，作为测试样本的预测值输出</td></tr></tbody></table><h3 id="参考资料">参考资料</h3><ol type="1"><li><a href="https://showmeai.tech/article-detail/187">图解机器学习 |KNN算法及其应用</a></li><li><ahref="https://blog.csdn.net/m0_74405427/article/details/133714384">KNN算法（k近邻算法）原理及总结-CSDN博客</a></li><li>机器学习.周志华</li></ol>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习，分类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>感知机(perceptron)学习笔记</title>
    <link href="/2024/11/28/%E6%84%9F%E7%9F%A5%E6%9C%BA/"/>
    <url>/2024/11/28/%E6%84%9F%E7%9F%A5%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<p>本文为感知机的学习笔记</p><span id="more"></span><h2 id="感知机perceptron">感知机(perceptron)</h2><p>有监督学习。误分类驱动。</p><h3 id="一-数学概念介绍">一 数学概念介绍</h3><h4 id="n维欧式空间rn"><spanclass="math inline">\(n\)</span>维欧式空间(<spanclass="math inline">\(R^n\)</span>)</h4><p>现实空间的抽象与推广</p><p>设<span class="math inline">\(n\)</span>是正整数，由<spanclass="math inline">\(n\)</span>个实数构成的有序数组<spanclass="math inline">\(x=(x_1,x_2,\dots,x_n)\)</span>的全体所组成的集合，称为<spanclass="math inline">\(n\)</span>维欧几里得空间。</p><h4 id="超平面">超平面</h4><p><span class="math inline">\(n\)</span>维欧氏空间中，<spanclass="math inline">\(n-1\)</span>维度的线性子空间。</p><p>是一个数学概率。</p><h4 id="gram矩阵">Gram矩阵</h4><p>一组向量内积的矩阵，给定一组向量<spanclass="math inline">\(v_1,v_2,\dots,v_n\)</span>，它们的Gram矩阵(<spanclass="math inline">\(n\)</span> x <spanclass="math inline">\(n\)</span>维度)如下：</p><p><span class="math display">\[ G = \begin{bmatrix} (\mathbf{v}_1 \cdot\mathbf{v}_1) &amp; (\mathbf{v}_1 \cdot \mathbf{v}_2) &amp; \cdots &amp;(\mathbf{v}_1 \cdot \mathbf{v}_n) \\ (\mathbf{v}_2 \cdot \mathbf{v}_1)&amp; (\mathbf{v}_2 \cdot \mathbf{v}_2) &amp; \cdots &amp; (\mathbf{v}_2\cdot \mathbf{v}_n) \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\(\mathbf{v}_n \cdot \mathbf{v}_1) &amp; (\mathbf{v}_n \cdot\mathbf{v}_2) &amp; \cdots &amp; (\mathbf{v}_n \cdot \mathbf{v}_n)\end{bmatrix} \]</span></p><h3 id="二-感知机">二 感知机</h3><p>使用一个超平面对数据集进行二分类。</p><p>类比神经元(两层神经元，输入层和输出层)，示意图如下：</p><figure><img src="./assets/神经元示意图.png" alt="神经元示意图" /><figcaption aria-hidden="true">神经元示意图</figcaption></figure><h4 id="定义说明">定义说明</h4><p>设训练数据集<spanclass="math inline">\(D=\{(x_1,y_1),\dots,(x_m,y_m)\}\)</span>。<spanclass="math inline">\((x_i,y_i)\)</span>表示第<spanclass="math inline">\(i\)</span>对样本。<span class="math inline">\(x\in \Chi \subseteq  R^n\)</span>，代表实例的特征向量。<spanclass="math inline">\(Y=\{+1,-1\}\)</span>，<spanclass="math inline">\(y \inY\)</span>，代表实例的类别。得到一个模型(<spanclass="math inline">\(f\)</span>代表激活函数(activate function)）: <spanclass="math display">\[f(x)=f(w \cdot x+b)\]</span> 其中，<spanclass="math inline">\(w\)</span>代表权值向量，其维度和特征向量<spanclass="math inline">\(x\)</span>相同；<spanclass="math inline">\(b\)</span>代表偏置，为超平面参数，对应的超平面为:<span class="math display">\[w \cdot x+b=0\]</span></p><h5 id="较典型的激活函数">较典型的激活函数</h5><table><thead><tr class="header"><th>名称</th><th>公式</th><th></th></tr></thead><tbody><tr class="odd"><td>符号函数<span class="math inline">\(sign(x)\)</span></td><td><span class="math inline">\(sign(x)=\begin{cases}+1, &amp; x \geq 0\\-1, &amp; x &lt; 0\end{cases}\)</span></td><td></td></tr><tr class="even"><td>阶跃函数<span class="math inline">\(sgn(x)\)</span></td><td><span class="math inline">\(sgn(x)=\begin{cases}1, &amp; x \geq 0\\0, &amp; x &lt; 0\end{cases}\)</span></td><td></td></tr><tr class="odd"><td><span class="math inline">\(Sigmoid\)</span>函数</td><td><spanclass="math inline">\(Sigmoid(x)=\frac{1}{1+e^{-x}}\)</span></td><td></td></tr></tbody></table><h4 id="线性可分">线性可分</h4><h5id="输入神经元数为二进行逻辑运算">输入神经元数为二，进行逻辑运算</h5><p>与、或、非为线性可分的问题，异或是非线性可分问题。</p><p>(1)与运算</p><figure><img src="./assets/与示意图.png" alt="与示意图" /><figcaption aria-hidden="true">与示意图</figcaption></figure><table><thead><tr class="header"><th><span class="math inline">\(x_1\)</span></th><th><span class="math inline">\(x_2\)</span></th><th><span class="math inline">\(y\)</span></th></tr></thead><tbody><tr class="odd"><td>1</td><td>1</td><td>1</td></tr><tr class="even"><td>1</td><td>0</td><td>0</td></tr><tr class="odd"><td>0</td><td>1</td><td>0</td></tr><tr class="even"><td>0</td><td>0</td><td>0</td></tr></tbody></table><p>(2)或运算</p><figure><img src="./assets/或示意图.png" alt="或示意图" /><figcaption aria-hidden="true">或示意图</figcaption></figure><table><thead><tr class="header"><th><span class="math inline">\(x_1\)</span></th><th><span class="math inline">\(x_2\)</span></th><th><span class="math inline">\(y\)</span></th></tr></thead><tbody><tr class="odd"><td>1</td><td>1</td><td>1</td></tr><tr class="even"><td>1</td><td>0</td><td>1</td></tr><tr class="odd"><td>0</td><td>1</td><td>1</td></tr><tr class="even"><td>0</td><td>0</td><td>0</td></tr></tbody></table><p>(3)非运算</p><figure><img src="./assets/非示意图.png" alt="非示意图" /><figcaption aria-hidden="true">非示意图</figcaption></figure><table><thead><tr class="header"><th><span class="math inline">\(x_1\)</span></th><th><span class="math inline">\(x_2\)</span></th><th><span class="math inline">\(y\)</span></th></tr></thead><tbody><tr class="odd"><td>1</td><td></td><td>0</td></tr><tr class="even"><td>0</td><td></td><td>1</td></tr></tbody></table><p>(4)异或运算</p><figure><img src="./assets/异或示意图.png" alt="异或示意图" /><figcaption aria-hidden="true">异或示意图</figcaption></figure><table><thead><tr class="header"><th><span class="math inline">\(x_1\)</span></th><th><span class="math inline">\(x_2\)</span></th><th><span class="math inline">\(y\)</span></th></tr></thead><tbody><tr class="odd"><td>1</td><td>1</td><td>0</td></tr><tr class="even"><td>1</td><td>0</td><td>1</td></tr><tr class="odd"><td>0</td><td>1</td><td>1</td></tr><tr class="even"><td>0</td><td>0</td><td>0</td></tr></tbody></table><p>无法找到一条直线去分开这两类点</p><h4 id="损失函数cost-function">损失函数(cost function)</h4><p>以选用符号函数<spanclass="math inline">\(sign(x)\)</span>作为激活函数来分析</p><h5 id="数据点到超平面的距离">数据点到超平面的距离</h5><p>首先考虑三维空间中点<spanclass="math inline">\((x_0,y_0,z_0)\)</span>到某平面<spanclass="math inline">\(c_1x+c_2y+c_3z+c_4=0\)</span>的距离<spanclass="math inline">\(d\)</span>公式： <span class="math display">\[d=\frac{\vert c_1x_0+c_2y_0+c_3z_0+c_4 \vert}{\sqrt{c_1^2+c_2^2+c_3^2}}\]</span> 再考虑输入变量<spanclass="math inline">\(x_i\)</span>到超平面<span class="math inline">\(w\cdot x+b=0\)</span>的距离公式: <span class="math display">\[d=\frac{\vert w \cdot x_i + b \vert}{\Vert w \Vert}\]</span> 由于选用了符号函数作为激活函数，可以得到误分类的数据<spanclass="math inline">\((x_i),y_i)\)</span>满足下列关系: <spanclass="math display">\[-y_i(w \cdot x_i+b)&gt;0\\\]</span></p><p><span class="math display">\[\begin{equation}\begin{split}-y_i(w \cdot x_i+b) &amp;=\vert w \cdot x_i + b \vert\end{split}\end{equation}\]</span></p><p>其中<span class="math inline">\(y_i\)</span>代表<spanclass="math inline">\(x_i\)</span>的真实类别。</p><p>可以得到样本点<span class="math inline">\(x_i\)</span>到超平面的距离:<span class="math display">\[d=\frac{-y_i(w \cdot x_i+b)}{\Vert w \Vert}\]</span>由不等式(5)判断出误分类点之后，可以得到一个由误分类点组成的集合<spanclass="math inline">\(M\)</span>，所有误分类点到超平面的总距离: <spanclass="math display">\[d_{\sum}=-\frac{1}{\Vert w \Vert}\sum_{x_i \in M}y_i(w \cdot x_i+b)\]</span></p><h5 id="优化目标">优化目标</h5><p>下列为感知机的损失函数: <span class="math display">\[L(w,b)=-\sum_{x_i \in M}y_i(w \cdot x_i+b)\]</span> 去掉公式(8)的<span class="math inline">\(\frac{1}{\Vert w\Vert}\)</span>的几种解释：</p><p>(1)希望使得误分类点到超平面的总距离合尽可能小，达到0最好，没有误分类点更好，所以在优化时，可以去掉公式(8)的<spanclass="math inline">\(\frac{1}{\Vert w \Vert}\)</span>。</p><p>(2)<span class="math inline">\(\frac{1}{\Vert w\Vert}\)</span>不影响对样本点是否被误分类的判断。</p><p><strong>优化目标</strong>是使得损失函数尽可能小。找到参数<spanclass="math inline">\(w\)</span>合<spanclass="math inline">\(b\)</span>满足: <span class="math display">\[\begin{equation}\begin{split}\underset {w,b}{L(w,b)}\end{split}\end{equation}\]</span></p><h4 id="学习算法">学习算法</h4><h5 id="原始形式">原始形式</h5><p>因为感知机学习是误分类驱动，不能使用全体样本进行梯度下降，下面是<strong>使用随机梯度下降法(StochasticGradient Descent，SGD)</strong>的介绍。</p><p>损失函数<span class="math inline">\(L(w,b)\)</span>对<spanclass="math inline">\(w\)</span>求梯度: <span class="math display">\[\nabla_w L(w,b)=-\sum_{x_i \in M}y_i\cdot x_i\]</span> 注意其中<spanclass="math inline">\(x_i\)</span>代表的是特征向量，不是一个数值。</p><p>损失函数<span class="math inline">\(L(w,b)\)</span>对<spanclass="math inline">\(b\)</span>求梯度: <span class="math display">\[\nabla_b L(w,b)=-\sum_{x_i \in M}y_i\]</span> 随 机选取一个误分类点<spanclass="math inline">\((x_i,y_i)\)</span>，对<spanclass="math inline">\(w\)</span>和<spanclass="math inline">\(b\)</span>进行更新: <span class="math display">\[w \leftarrow w-\eta(-y_i\cdot x_i)=w+\eta(y_i\cdot x_i)\\b \leftarrow b-\eta(-y_i)=b+\eta(y_i)\]</span></p><h5 id="对偶形式">对偶形式</h5><p>设误分类点<span class="math inline">\((x_i,y_i)\)</span>，假设<spanclass="math inline">\(w\)</span>和<spanclass="math inline">\(b\)</span>初始为<spanclass="math inline">\(0\)</span>向量</p><p>一个分类点迭代<span class="math inline">\(n_i\)</span>次之后，<spanclass="math inline">\(w\)</span>的增量：<spanclass="math inline">\(n_i\eta y_i x_i=\alpha_i y_i  x_i\)</span></p><p>一个分类点迭代<span class="math inline">\(n_i\)</span>次之后，<spanclass="math inline">\(b\)</span>的增量：<spanclass="math inline">\(n_i\eta y_i=\alpha_i y_i\)</span></p><p>其中，<span class="math inline">\(\alpha_i=n_i \eta\)</span></p><p>由第二部分的定义说明，训练数据集中一共有<spanclass="math inline">\(m\)</span>个样本点，故最后学习到的<spanclass="math inline">\(w\)</span>和<spanclass="math inline">\(b\)</span>如下： <span class="math display">\[\begin{equation}\begin{split}w&amp;=\sum_{i=1}^{m}{\alpha_iy_i x_i}\\b&amp;=\sum_{i=1}^{m}{\alpha_iy_i}\end{split}\end{equation}\]</span> 将公式(14)代入公式(1)得感知机对偶形式： <spanclass="math display">\[f(x)=f(\sum_{i=1}^{m}{\alpha_i y_i x_i \cdot x+b})\]</span></p><p>其中<spanclass="math inline">\(\alpha=(\alpha_1,\alpha_2,\dots,\alpha_m)^T\)</span></p><table><thead><tr class="header"><th>对偶形式的算法流程：</th></tr></thead><tbody><tr class="odd"><td>输入：训练数据集<spanclass="math inline">\(D=\{(x_1,y_1),\dots,(x_m,y_m)\}\)</span>，学习率<spanclass="math inline">\(\eta\)</span></td></tr><tr class="even"><td>(1)<span class="math inline">\(\alpha \leftarrow 0\)</span>,<spanclass="math inline">\(b \leftarrow 0\)</span></td></tr><tr class="odd"><td>(2)训练集中选择<span class="math inline">\((x_j,y_j)\)</span></td></tr><tr class="even"><td>(3)if $y_j(_{i=1}^{m}{_i y_i x_i x_j+b}) $<br /> <spanclass="math inline">\(\alpha_j \leftarrow \alpha_j+1\)</span>,<spanclass="math inline">\(b \leftarrow b+y_j\)</span></td></tr><tr class="odd"><td>(4)转到(2)直到无误分类</td></tr></tbody></table><h3 id="参考">参考</h3><p>1、《统计学习方法》</p><p>2、《机器学习》</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习，感知机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性回归(linear regression)学习笔记</title>
    <link href="/2024/11/28/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    <url>/2024/11/28/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</url>
    
    <content type="html"><![CDATA[<p>本文为线性回归算法的学习笔记</p><span id="more"></span><h2 id="线性回归linear-regression">线性回归(linear regression)</h2><p>有监督学习。</p><p>给定数据集<spanclass="math inline">\(D=\{(x_1,y_1),\dots,(x_m,y_m)\}\)</span>，其中<spanclass="math inline">\(x_i=(x_{i1},\dots,x_{id})\)</span>,<spanclass="math inline">\(\in\mathbb{R}\)</span>。线性回归尝试学得一个模型去准确预测输出值。</p><table><thead><tr class="header"><th>按输入变量个数分类</th><th>输入变量个数</th></tr></thead><tbody><tr class="odd"><td>一元回归</td><td>1</td></tr><tr class="even"><td>多元回归</td><td>多个</td></tr></tbody></table><h3 id="原理">原理</h3><p>学得一个模型(1)，去由输入预测输出： <span class="math display">\[f(x_i)=w \cdot x_i+b\]</span> 其中("<spanclass="math inline">\(\cdot\)</span>"代表向量点积):</p><p><span class="math display">\[w=(w_1,w_2,\dots,w_d)\\\]</span></p><p><span class="math inline">\(w\)</span>代表权值，<spanclass="math inline">\(b\)</span>代表偏置</p><h4 id="损失函数cost-function">损失函数(cost function)</h4><p><span class="math display">\[J=\frac{1}{2}\sum_{i=1}^m[f(x_i;\omega;b)-y_i]^2\]</span></p><h4 id="目标">目标</h4><p>最小化代价函数<span class="math inline">\(J\)</span></p><h4 id="方法">方法</h4><h5 id="梯度下降">梯度下降</h5><p>对代价函数求偏导： <span class="math display">\[\frac{\partial J}{\partial w}=(\omega\cdot x_i+b-y_i) \cdot x_i\]</span> <span class="math display">\[\frac{\partial J}{\partial b}=(\omega\cdot x_i+b-y_i)\]</span></p><p><span class="math inline">\(w\)</span>和<spanclass="math inline">\(b\)</span>的更新公式为: <spanclass="math display">\[\begin{equation}\begin{split}w \leftarrow w-\eta \frac{\partial J}{\partial w}&amp;=w-\eta(w\cdotx_i+b-y_i)\cdot x_i\\b \leftarrow b-\frac{\partial J}{\partial b}&amp;= b-\eta(w\cdotx_i+b-y_i)\\\end{split}\end{equation}\]</span> 其中<span class="math inline">\(\eta\)</span>为学习率。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习，线性回归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>以倒立摆为例，学习设计LQR控制器</title>
    <link href="/2024/05/17/LQR%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    <url>/2024/05/17/LQR%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>本文先介绍LQR算法，然后以一阶倒立摆为例，设计一个LQR控制器<span id="more"></span></p><h1id="以一阶倒立摆为例学习使用lqr控制器">以一阶倒立摆为例,学习使用LQR控制器</h1><p><strong><span class="citation" data-cites="author">@author</span>:Liao Yufei</strong></p><p>本文中，当不描述文中所指的一阶倒立摆系统时，<spanclass="math inline">\(x、y、u、e、A、B、C、D、K、S、J\)</span>等符号均代表对普遍性的状态空间方程和LQR理论的描述。</p><h2 id="一线性二次型调节器lqr">一、线性二次型调节器(LQR)</h2><h3id="最优控制和线性二次型调节器的关系">1、最优控制和线性二次型调节器的关系</h3><p>最优控制的目的是设计出最优的控制策略，我们希望能用最少的能量、最高的效率去达成对系统的控制。最优控制理论涉及到极小值原理、变分法、动态规划等理论。最优控制对问题的描述一般包括运动方程、状态约束条件、目标集、容许控制集、性能指标等等。</p><p>线性二次型调节器是基于最优控制理论的一种控制器，其所选取的性能指标函数(代价函数)为二次型。</p><h3 id="代价函数cost-function简介">2、代价函数(cost function)简介</h3><p>代价函数通常是用于寻找最优解的一种函数，一般用符号J表示，其可用于代表解决问题所需的代价。代价函数中通常包含了预测值和真实值间的差异。使用代价函数的目的是用最少的能量达到最优的控制效果，在算法设计中，通常希望所设计的代价函数的值能够达到最小。</p><p>在许多算法中都看到代价函数的身影，比如最优控制、机器学习等等。</p><p>在最优控制中，通常可以看到将代价函数称为性能指标函数。</p><p><strong>LQR中选取的代价函数为二次型。</strong>对于二次型的代价函数来说，可以在其前面乘<spanclass="math inline">\(\frac{1}{2}\)</span>，这是为了在原理公式的推导中简化计算，使结果简洁。如果只是使用LQR控制器，不会涉及到LQR原理的深入计算。</p><h3id="线性二次型有限时间最优状态调节器">3、线性二次型有限时间最优状态调节器</h3><h4id="连续时间系统有限时间最优状态调节器">（1）连续时间系统有限时间最优状态调节器</h4><p>假设一个线性系统： <span class="math display">\[\begin{align}\dot{x}(t) = A(t)x(t) + B(t)u(t)\\y(t)=C(t)x(t)+D(t)u(t)\end{align}\]</span></p><p>此情况下代价函数(也称为性能指标)一般设置为： <spanclass="math display">\[\begin{align}J=\frac{1}{2}x^{T}(t_f)S(t_f)x(t_f)+\frac{1} {2}\int_{t_0}^{t_f}[x^{T}(t)Q(t)x(t) + u^{T}(t)R(t)u(t)] dt \label{2eq}\\\end{align}\]</span></p><h4id="离散时间系统有限时间最优状态调节器">（2）离散时间系统有限时间最优状态调节器</h4><p>初始条件为<span class="math inline">\(x(0) = x_0\)</span></p><p>代价函数一般设置为： <span class="math display">\[\begin{align}J = \frac{1}{2}x^{T}(N)S(N)x(N) +\frac{1}{2}\sum_{k=0}^{N-1}[x^{T}(k)Q(k)x(k)+u^{T}(k)R(k)u(k)]\end{align}\]</span></p><h3id="线性二次型无限时间最优状态调节器">4、线性二次型无限时间最优状态调节器</h3><p><strong>一般我们所说的LQR是指无限时间上的线性二次型调节器</strong>。</p><h4id="连续时间系统无限时间最优状态调节器">（1）连续时间系统无限时间最优状态调节器</h4><h5 id="a.对于线性时变系统">a.对于线性时变系统</h5><p>描述系统的微分方程中有系数为时间的函数，此时其无限时间上的LQR问题相当于是在<spanclass="math inline">\(t_f\)</span>趋于无穷下的有限时间LQR问题。由于当<spanclass="math inline">\(t\)</span>趋于0时，系统状态稳定，表示系统终端状态的项数值也趋于0</p><h5 id="b.对于线性定常系统">b.对于线性定常系统</h5><p><span class="math display">\[\begin{align}\dot{x}(t) = Ax(t) + Bu(t)\\y(t)=Cx(t)+Du(t)\end{align}\]</span></p><p>A、B、C和D矩阵均为常矩阵。</p><p><strong>代价函数</strong>一般设置为： <span class="math display">\[\begin{align}J=\frac{1}{2}\int_{0}^{\infty} [x^{T}(t)Qx(t) + u^{T}(t)R u(t) ]dt \\\end{align}\]</span></p><p>​可以看到此代价函数没有表示终端状态的项，因为当时间趋于无穷时，系统状态稳定，<spanclass="math inline">\(x(t)\)</span>趋近于0。</p><p>​Q是半正定常数矩阵、R是正定常数矩阵。一般设置Q和R为对角线矩阵。Q和R矩阵内的元素值大小可以理解为对状态向量和系统输入向量中相应元素的权重分配。</p><p>对于线性负反馈闭环系统有（<spanclass="math inline">\(K\)</span>为反馈增益矩阵）： <spanclass="math display">\[\begin{align}u(t) = -Kx(t)\end{align}\]</span> 将式(8)代入式(7)，可得到： <span class="math display">\[\begin{align}J = \frac{1}{2}\int_{0}^{\infty} x^{T}(t)(Q+K^TRK)x(t)dt\end{align}\]</span></p><p>当<span class="math inline">\((A,B)\)</span>为可镇定对，<spanclass="math inline">\(u^*(t)\)</span>是线性定常系统无限时间LQR问题存在的唯一最优控制器。其中<spanclass="math inline">\(P\)</span>矩阵是式(12)所示的<spanclass="math inline">\(Riccati\)</span>黎卡提方程的非负定解。 <spanclass="math display">\[\begin{align}u^*(t) = -R^{-1}B^TPx(t)\end{align}\]</span></p><p><span class="math display">\[\begin{align}令&amp;K = R^{-1}B^{T}P\\\end{align}\]</span></p><p>补充：对于线性定常系统，<spanclass="math inline">\((A,B)\)</span>是可镇定对，意为存在反馈增益矩阵<spanclass="math inline">\(K\)</span>，使得<spanclass="math inline">\(A-BK\)</span>稳定。 <span class="math display">\[\begin{align}&amp;A^TP + PA + Q - PBR^{-1}B^{T}P = 0\\\end{align}\]</span></p><p>可用如下方式得到该<spanclass="math inline">\(Riccati\)</span>黎卡提方程：</p><p>假设存在常数矩阵P，使 <span class="math display">\[\begin{align}\frac{\mathrm{d}(x^T(t)Px(t))}{\mathrm{d}t} =  -x^{T}(t)(Q+K^TRK)x(t)\end{align}\]</span> 将上式展开，可得到： <span class="math display">\[\begin{align}\dot{x}^T(t)Px(t)+x^T(t)P\dot{x}(t)= -x^{T}(t)(Q+K^TRK)x(t)\end{align}\]</span> 对于线性负反馈系统<spanclass="math inline">\(\dot{x}(t)=Ax(t)+Bx(t)\)</span>，结合式(8)可得到：<span class="math display">\[\begin{align}\dot{x}(t)=(A-BK)x(t)\end{align}\]</span> 将式(15)代入式(14)： $$ <spanclass="math display">\[\begin{align}&amp;x^T(t){(A-BK)}^TPx(t)+x^T(t)P(A-BK)x(t)+x^{T}(t)(Q+K^TRK)x(t) = 0\\&amp;x^T(t)(A^TP+PA+Q+K^TRK-K^TBP-PBK)x(t)=0\\\end{align}\]</span> <span class="math display">\[为使式(17)恒成立，可得：\]</span> <span class="math display">\[\begin{align}A^TP+PA+Q+K^TRK-K^TBP-PBK=0\end{align}\]</span> <span class="math display">\[代入式(11)化简可得：\]</span> A^TP + PA + Q - PBR<sup>{-1}B</sup>{T}P = 0 <spanclass="math display">\[当期望的状态变量不为0时，可将代价函数设置为：\]</span> <span class="math display">\[\begin{align}J=\frac{1}{2}\int_{0}^{\infty} [e^{T}(t)Qe(t) + u^{T}(t)R u(t) ]dt \\\end{align}\]</span> <span class="math display">\[\]</span> 其中<span class="math inline">\(e(t) =x(t)-x_{ref}(t)\)</span> $$</p><h4id="离散时间系统无限时间最优状态调节器">（2）离散时间系统无限时间最优状态调节器</h4><p>初始条件为<span class="math inline">\(x(0) = x_0\)</span></p><p><span class="math display">\[\begin{align}J = \frac{1}{2}\sum_{k=0}^{N-1}[x^{T}(k)Qx(k)+u^{T}(k)Ru(k)]\end{align}\]</span></p><h2 id="二一阶倒立摆力学模型">二、一阶倒立摆力学模型</h2><p>补充：平行轴定理</p><p>设<spanclass="math inline">\(I_c\)</span>代表刚体对于质心轴的转动惯量，该刚体质量为M，设与质心轴垂直距离为<spanclass="math inline">\(l\)</span>的轴1，则该刚体相对于轴1的转动惯量为<spanclass="math inline">\(I = I_c + Ml^2\)</span></p><figure><imgsrc="https://github.com/LiaoYFBH/my_ppp/blob/main/olp_cen_use.png?raw=true"alt="图1 一阶倒立摆" /><figcaption aria-hidden="true">图1 一阶倒立摆</figcaption></figure><table><thead><tr class="header"><th>符号</th><th>意义</th><th>单位</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(m\)</span></td><td>摆杆质量</td><td><span class="math inline">\(kg\)</span></td></tr><tr class="even"><td><span class="math inline">\(M\)</span></td><td>滑块质量</td><td><span class="math inline">\(kg\)</span></td></tr><tr class="odd"><td><span class="math inline">\(l\)</span></td><td>摆杆质心到摆杆转动点的距离</td><td><span class="math inline">\(m\)</span></td></tr><tr class="even"><td><span class="math inline">\(b\)</span></td><td>滑块与导轨阻尼系数</td><td><span class="math inline">\(N·s/m\)</span></td></tr><tr class="odd"><td></td><td></td><td></td></tr></tbody></table><table><thead><tr class="header"><th>符号</th><th>意义</th><th>设定正方向</th><th>单位</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\phi\)</span></td><td>摆杆与竖直方向的夹角</td><td>图示为正</td><td>°</td></tr><tr class="even"><td><span class="math inline">\(\dot{\phi}\)</span></td><td>摆杆与竖直方向的夹角角速度</td><td>顺时针</td><td>°/<span class="math inline">\(s\)</span></td></tr><tr class="odd"><td><span class="math inline">\(\ddot{\phi}\)</span></td><td>摆杆与竖直方向的夹角角加速度</td><td>与Y轴正方向平行</td><td>°/<span class="math inline">\(s^2\)</span></td></tr><tr class="even"><td><span class="math inline">\(x_m\)</span></td><td>滑块位移</td><td>与x轴正方向平行</td><td><span class="math inline">\(m\)</span></td></tr><tr class="odd"><td><span class="math inline">\(\dot{x}_m\)</span></td><td>滑块速度</td><td>与x轴正方向平行</td><td><span class="math inline">\(m/s\)</span></td></tr><tr class="even"><td><span class="math inline">\(\ddot{x}_m\)</span></td><td>滑块加速度</td><td>与x轴正方向平行</td><td><span class="math inline">\(m/s^{2}\)</span></td></tr></tbody></table><p>进行力学分析可建立以下方程：</p><p><span class="math display">\[\begin{align}&amp; F = (m + M) \ddot{x}_m + ml\ddot{\phi}cos\phi - ml\dot{\phi}^2sin\phi + b\dot{x}_m\end{align}\]</span> <span class="math display">\[\begin{align}&amp; (J + ml^2)\ddot{\phi} = mglsin\phi - m\ddot{x}_mlcos\phi\end{align}\]</span></p><h2 id="三设计lqr控制器">三、设计LQR控制器</h2><p>设计LQR控制器需要精确的数学模型。如果无法直接测量获得系统状态向量里所有的状态值，则需要设计状态观测器来估计无法测量的状态值。</p><p>以一阶倒立摆为例介绍LQR控制器的设计步骤：</p><h4 id="对被控制的系统进行建模">1、对被控制的系统进行建模</h4><h5 id="建立该系统中各变量的关系">（1）建立该系统中各变量的关系</h5><p>对图1所示一阶倒立摆系统进行力学分析，能够得到方程(21)、方程(22)。可以看出一阶倒立摆系统是一个非线性系统。</p><h5 id="建立状态向量">（2）建立状态向量</h5><p>选取一组数量最少的、能够完全表征系统运动状态的变量作为状态变量，建立状态向量。</p><p>对于如图1所示一阶倒立摆系统来说，关于变量<spanclass="math inline">\(x_m\)</span>的微分方程最高阶导数项为<spanclass="math inline">\(\ddot{x}_m\)</span>，关于变量<spanclass="math inline">\(\phi\)</span>的微分方程最高阶导数项为<spanclass="math inline">\(\ddot{\phi}\)</span>，结合实际情况分析，故用滑块位移<spanclass="math inline">\(x_m\)</span>、滑块速度<spanclass="math inline">\(\dot{x}_m\)</span>、摆杆与竖直方向夹角<spanclass="math inline">\(\phi\)</span>以及该夹角的角速度<spanclass="math inline">\(\dot{\phi}\)</span>便能表征该系统的运动状态，选取这四个变量为状态变量，构造状态向量<spanclass="math inline">\(X\)</span> <span class="math display">\[\begin{align}X = \left[\begin{array}{ccc}     {x_m}\\     \dot{x}_m\\     {\phi}\\     \dot{\phi}\end{array}\right]        \\\end{align}\]</span></p><h5 id="确定该被控系统的输入和输出">（3）确定该被控系统的输入和输出</h5><p>对于如图1所示一阶倒立摆系统来说，其系统的输入是除了系统内力和重力之外的外部力，即图中的<spanclass="math inline">\(F\)</span>力，故该一阶倒立摆系统的输入<spanclass="math inline">\(U=F\)</span>，可将滑块位移<spanclass="math inline">\(x_m\)</span>和摆杆与竖直方向夹角<spanclass="math inline">\(\phi\)</span>看作系统的输出 <spanclass="math display">\[\begin{align}Y = \left[\begin{array}{ccc}     {x_m}\\     {\phi}\\\end{array}\right] \\\end{align}\]</span></p><h5 id="建立状态空间方程">（4）建立状态空间方程</h5><p>状态空间方程是用来描述系统输入、输出和状态变量之间关系的方程组。</p><p>一般的状态空间方程表达式为： <span class="math display">\[\begin{align}\left\{\begin{array}{lr}\dot{x} = Ax + Bu\\\notagy=Cx+Du\end{array}\right.\notag\end{align}\]</span></p><h6 id="a.对于线性系统">a.对于线性系统</h6><p>需要将物理模型的微分方程和传递函数转化为状态空间方程。</p><h6 id="b.对于非线性系统">b.对于非线性系统</h6><p>需要将非线性系统在平衡点处进行线性化。</p><p>需要建立系统状态向量、系统输入关系和时间的关系，其关系方程可用下列式(25)来表示。<span class="math display">\[\begin{align}\dot{x(t)} = f(x(t),u(t),t)\end{align}\]</span></p><p>用该方程分别对状态向量<spanclass="math inline">\(x\)</span>和系统输入<spanclass="math inline">\(u\)</span>求雅可比矩阵，所求的雅可比矩阵分别为状态空间方程中的A、B矩阵。再根据关系列写出C、D矩阵。</p><h6id="建立本文中一阶倒立摆系统的状态空间方程">建立本文中一阶倒立摆系统的状态空间方程</h6><p>容易该一阶倒立摆系统的状态向量一阶导数向量为： <spanclass="math display">\[\begin{align}\dot{X} = \left[\begin{array}{ccc}     \dot{x}_m\\     \ddot{x}_m\\     \dot{\phi}\\     \ddot{\phi}\end{array}\right]        \end{align}\]</span></p><p>由于该系统是非线性系统，故需要对该系统在平衡点附近进行线性化，实际的倒立摆的稳定工作点处摆角较小，可认为平衡点为<spanclass="math inline">\(\phi = 0\)</span>​，<spanclass="math inline">\(\dot{\phi}=0\)</span></p><p>对于平衡点<span class="math inline">\(\phi =0\)</span>附近来说，由等价无穷小公式：<spanclass="math inline">\(sin\phi \sim \phi ,1-cos\phi \sim\frac{\phi^2}{2}\)</span>，可以得到在平衡点<spanclass="math inline">\(\phi = 0\)</span>附近，<spanclass="math inline">\(sin\phi \approx  0,cos\phi \approx 1\)</span></p><p>第一种计算方法：</p><p>将<span class="math inline">\(\dot{X}\)</span>中不属于状态向量<spanclass="math inline">\(X\)</span>元素、系统输入<spanclass="math inline">\(U\)</span>元素、可直接测量得到的已知常量的元素，分别用这三种变量去表示。</p><p>利用matlab，用状态向量的一阶导数向量分别对状态向量和输入求雅克比矩阵：<span class="math inline">\(A_1\)</span>(因篇幅过长，暂时不在此给出)</p><p>$$ <span class="math display">\[\begin{align}&amp;B_1=\left[\begin{array}{c}0\\\frac{ml^2 +J}{\sigma_1 }\\0\\-\frac{lm\cos \left(\phi \right)}{\sigma_1 }\end{array}\right]\\&amp;\sigma_1 =-l^2 m^2 {\cos \left(\phi \right)}^2 +l^2 m^2 +Ml^2m+Jm+JM\end{align}\]</span> $$</p><p>代入<span class="math inline">\(\phi = 0\)</span>，<spanclass="math inline">\(\dot{\phi}=0\)</span>有： <spanclass="math display">\[\begin{align}A_1 = \left[\begin{array}{ccc}     0 &amp; 1 &amp; 0 &amp; 0\\     0 &amp; -\frac{(J+ml^2)b}{Mml^2+J(m+M)}&amp;-\frac{gm^2l^2}{Mml^2+J(m+M)} &amp; 0\\     0 &amp; 0 &amp; 0 &amp; 1\\     0 &amp; -\frac{blm}{Mml^2+J(m+M)} &amp;\frac{lmg(M+m)}{Mml^2+J(m+M)} &amp; 0\\\end{array}\right]        \end{align}\]</span></p><p><span class="math display">\[\begin{align}&amp;B_1=\left[\begin{array}{c}0\\\frac{ml^2 +J}{Mml^2+J(m+M)}\\0\\-\frac{lm}{Mml^2+J(m+M) }\end{array}\right]\\\end{align}\]</span></p><p>代入系统中摆杆质量、摆杆转动惯量、滑块质量、摆杆质心到摆杆转动点的距离和滑块与导轨阻尼系数，即可求得式(29)、式(30)所示雅可比矩阵的数值矩阵。</p><p>该一阶倒立摆系统输出：<span class="math inline">\(Y = C_1X +D_1U\)</span></p><p>容易得到：<span class="math inline">\(C_1=\left[\begin{array}{ccc}     1 &amp; 0 &amp; 0  &amp; 0\\     0 &amp; 0 &amp; 1 &amp; 0 \\\end{array}\right]  ,D_1=\left[\begin{array}{ccc}     0  \\     0  \\\end{array}\right]\)</span></p><p>另一种计算方法：</p><p>先利用在平衡点<span class="math inline">\(\phi =0\)</span>附近，<span class="math inline">\(sin\phi \approx  0,cos\phi\approx1\)</span>，化简方程(21)、(22)，然后再进行线性化，求雅可比矩阵。</p><h4 id="设计lqr控制器">2、设计LQR控制器</h4><h5 id="绘制控制方框图">（1）绘制控制方框图</h5><p>示例</p><p>一阶倒立摆LQR控制方框图如下：</p><figure><imgsrc="https://github.com/LiaoYFBH/my_ppp/blob/main/LQR_Con_Olp_x.png?raw=true"alt="图2 LQR控制框图" /><figcaption aria-hidden="true">图2 LQR控制框图</figcaption></figure><h5 id="求解和设置参数">（2）求解和设置参数</h5><p>由<spanclass="math inline">\(u(t)=-Kx(t)\)</span>可得该一阶倒立摆系统的反馈增益矩阵为：<span class="math display">\[K_1=\left[\begin{array}{ccc}     k_{11} &amp; k_{12} &amp; k_{13} &amp; k_{14}  \\\end{array}\right]\]</span></p><h6 id="a.设置系统初值">a.设置系统初值</h6><h6 id="b.设置q和r矩阵">b.设置Q和R矩阵</h6><p>由于目标是使得代价函数<spanclass="math inline">\(J\)</span>最小，当半正定加权矩阵<spanclass="math inline">\(Q\)</span>值设置得越大，<spanclass="math inline">\(x(t)\)</span>就需要越小，<spanclass="math inline">\(x(t)\)</span>衰减速度会更快达到0，系统能更快达到稳定；当正定加权矩阵R值设置得越大。系统衰减速度会变慢。</p><p>一般选取Q和R为对角矩阵，此时Q矩阵对角元素应设置为非负且所有元素不能全设为0；R矩阵对角元素应全设置为正数。</p><h6 id="c.求解p和k">c.求解<span class="math inline">\(P\)</span>和<spanclass="math inline">\(K\)</span></h6><p>由于LQR的计算十分复杂，所以可以利用matlab等软件来进行计算求解，可以正确使用函数matlab中lqr()、lqrd()或者dlqr()等函数。</p><h6 id="d.求解u">d.求解<span class="math inline">\(u\)</span></h6><p><span class="math inline">\(u(t)=-Kx(t)\)</span></p><h5id="按照设计的控制方框图进行仿真">（3）按照设计的控制方框图进行仿真</h5><figure><imgsrc="https://github.com/LiaoYFBH/my_ppp/blob/main/%E5%80%92%E7%AB%8B%E6%91%86%E4%BB%BF%E7%9C%9F%E5%9B%BE1.png?raw=true"alt="图3 阶跃响应仿真图" /><figcaption aria-hidden="true">图3 阶跃响应仿真图</figcaption></figure><p>​</p><figure><imgsrc="https://github.com/LiaoYFBH/my_ppp/blob/main/%E5%80%92%E7%AB%8B%E6%91%86%E4%BB%BF%E7%9C%9F%E5%9B%BE.png?raw=true"alt="图4 simscape倒立摆仿真" /><figcaption aria-hidden="true">图4 simscape倒立摆仿真</figcaption></figure><h5 id="部署代码">（4）部署代码</h5><h3 id="参考文献">参考文献：</h3><p>[1] 钟宜生.最优控制.清华大学出版社.2015.</p><p>[2] 林乐天.基于卡尔曼滤波器的一阶倒立摆控制研究[D].哈尔滨工业大学,2012.</p><p>[3] 田涛.基于鲁棒最优控制的舵减摇控制系统研究[D].哈尔滨工程大学,2022.</p><p>[4]LQR控制器— 线性二次型调节器 Linear Quadratic Regulator<ahref="https://zhuanlan.zhihu.com/p/139145957">20. LQR控制器—线性二次型调节器 Linear Quadratic Regulator - 知乎 (zhihu.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>控制理论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>坐标系变换，旋转矩阵，四元数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux下配置强化学习环境</title>
    <link href="/2024/05/17/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/"/>
    <url>/2024/05/17/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<p>在WSL ubuntu 20.04下，配置配置强化学习环境(PyTorch、Anaconda、JupyterNoteBook) <span id="more"></span></p><h2 id="一-linux下配置强化学习环境">一、 Linux下配置强化学习环境</h2><p>我个人使用的WSL ubuntu 20.04，PyTorch、Anaconda、Jupyter NoteBook</p><h3 id="安装anaconda">1.1 安装Anaconda</h3><p>到官网下载相应版本<ahref="https://www.anaconda.com/download/success">Download Now |Anaconda</a></p><p>例如我下载的是Anaconda3-2024.02-1-Linux-x86_64.sh</p><p>打开下载路径，运行</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">bash</span> Anaconda3-<span class="hljs-number">2024</span>.<span class="hljs-number">02</span>-<span class="hljs-number">1</span>-Linux-x86_64.sh<br></code></pre></td></tr></table></figure><p>出现下列提示：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">If yo<span class="hljs-string">u&#x27;d prefer that conda&#x27;</span>s base environment not be activated on startup,<br>   run the following command when conda is activated:<br><br>conda config --set auto_activate_base false<br><br>You can undo this by running `conda init --reverse <span class="hljs-variable">$SHELL</span>`? [yes|no]<br></code></pre></td></tr></table></figure><p>根据自己需要选择即可</p><h4 id="创建环境">创建环境</h4><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">conda <span class="hljs-built_in">create</span> <span class="hljs-comment">--name rl python=填python版本号</span><br></code></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Downloading and Extracting Packages:</span><br><br><span class="hljs-attr">Preparing transaction:</span> <span class="hljs-string">done</span><br><span class="hljs-attr">Verifying transaction:</span> <span class="hljs-string">done</span><br><span class="hljs-attr">Executing transaction:</span> <span class="hljs-string">done</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># To activate this environment, use</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#     $ conda activate rl</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># To deactivate an active environment, use</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#     $ conda deactivate</span><br></code></pre></td></tr></table></figure><p>运行下列命令行，检查自己环境是否创建成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda <span class="hljs-built_in">env</span> list<br></code></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># conda environments:</span><br><span class="hljs-comment">#</span><br>base                  *  <span class="hljs-regexp">/xxxx/</span>anaconda3<br>rl                       <span class="hljs-regexp">/xxxx/</span>anaconda3<span class="hljs-regexp">/envs/</span>rl<br></code></pre></td></tr></table></figure><h4 id="查看创建成功的环境">查看创建成功的环境</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda <span class="hljs-built_in">env</span> list<br></code></pre></td></tr></table></figure><h4 id="激活指定的环境">激活指定的环境</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-built_in">activate</span> rl<br></code></pre></td></tr></table></figure><h4 id="退出创建的环境">退出创建的环境</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">conda deactivate</span><br></code></pre></td></tr></table></figure><h4id="删除所创建的环境rl--all完全删除">删除所创建的环境rl（--all，完全删除）</h4><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">conda remove</span> <span class="hljs-literal">--</span><span class="hljs-comment">name rl</span> <span class="hljs-literal">--</span><span class="hljs-comment">all</span><br></code></pre></td></tr></table></figure><h3 id="pytorch安装">1.2 PyTorch安装</h3><p>官网：<a href="https://pytorch.org/">PyTorch</a></p><figure><img src="/assets/image-20240428182007432.png"alt="image-20240428182007432" /><figcaption aria-hidden="true">image-20240428182007432</figcaption></figure><p>点击进入Get Started界面，按需要选择配置之后，将"Run thisCommand"的命令复制到命令行里。</p><h3 id="jupyter-notebook的安装">1.3 Jupyter Notebook的安装</h3><p>终端使用命令行</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">pip <span class="hljs-keyword">install </span><span class="hljs-keyword">jupyter </span>notebook<br></code></pre></td></tr></table></figure><p>安装完成之后打开Jupyter Notebook</p><p>命令行输入：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">jupyter notebook</span><br></code></pre></td></tr></table></figure><p>复制终端里的相应链接到浏览器打开</p><figure><img src="/assets/image-20240512133610159.png"alt="image-20240512133610159" /><figcaption aria-hidden="true">image-20240512133610159</figcaption></figure><p><img src="/assets/image-20240512133954633.png"alt="image-20240512133954633" /><imgsrc="/assets/image-20240512134056096.png"alt="image-20240512134056096" /></p><h3 id="gym">1.4 GYM</h3><p>github源码网址：[GitHub - openai/gym: A toolkit for developing andcomparing reinforcement learning algorithms.](https://github.com/openai/gym)</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">http</span>://github.com/openai/gym.git<br></code></pre></td></tr></table></figure><p>注释掉setup.py里的</p><figure><img src="/assets/image-20240512145155947.png"alt="image-20240512145155947" /><figcaption aria-hidden="true">image-20240512145155947</figcaption></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> gym<br>pip install -e <span class="hljs-string">&#x27;.[all]&#x27;</span><br></code></pre></td></tr></table></figure><p>出现报错</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs awk">× python setup.py bdist_wheel did not run successfully.<br>  │ <span class="hljs-keyword">exit</span> code: <span class="hljs-number">1</span><br>  ╰─&gt; [<span class="hljs-number">17</span> lines of output]<br>      Using setuptools (version <span class="hljs-number">45.2</span>.<span class="hljs-number">0</span>).<br>      running bdist_wheel<br>      running build<br>      running build_py<br>      creating build<br>      creating build/lib.linux-x86_64-<span class="hljs-number">3.8</span><br>      creating build<span class="hljs-regexp">/lib.linux-x86_64-3.8/</span>Box2D<br>      copying library<span class="hljs-regexp">/Box2D/</span>Box2D.py -&gt; build<span class="hljs-regexp">/lib.linux-x86_64-3.8/</span>Box2D<br>      copying library<span class="hljs-regexp">/Box2D/</span>__init__.py -&gt; build<span class="hljs-regexp">/lib.linux-x86_64-3.8/</span>Box2D<br>      creating build<span class="hljs-regexp">/lib.linux-x86_64-3.8/</span>Box2D/b2<br>      copying library<span class="hljs-regexp">/Box2D/</span>b2<span class="hljs-regexp">/__init__.py -&gt; build/</span>lib.linux-x86_64-<span class="hljs-number">3.8</span><span class="hljs-regexp">/Box2D/</span>b2<br>      running build_ext<br>      building <span class="hljs-string">&#x27;Box2D._Box2D&#x27;</span> extension<br>      swigging Box2D<span class="hljs-regexp">/Box2D.i to Box2D/</span>Box2D_wrap.cpp<br>      swig -python -c++ -IBox2D -small -O -includeall -ignoremissing -w201 -globals b2Globals -outdir library<span class="hljs-regexp">/Box2D -keyword -w511 -D_SWIG_KWARGS -o Box2D/</span>Box2D_wrap.cpp Box2D/Box2D.i<br>      unable to execute <span class="hljs-string">&#x27;swig&#x27;</span>: No such file or directory<br>      error: command <span class="hljs-string">&#x27;swig&#x27;</span> failed with <span class="hljs-keyword">exit</span> status <span class="hljs-number">1</span><br>      [end of output]<br><br>  note: This error originates from a subprocess, and is likely not a problem with pip.<br>  ERROR: Failed building wheel <span class="hljs-keyword">for</span> box2d-py<br>  Running setup.py clean <span class="hljs-keyword">for</span> box2d-py<br>  Building wheel <span class="hljs-keyword">for</span> moviepy (setup.py) ... done<br>  Created wheel <span class="hljs-keyword">for</span> moviepy: filename=moviepy-<span class="hljs-number">1.0</span>.<span class="hljs-number">3</span>-py3-none-any.whl size=<span class="hljs-number">110730</span> sha256=dff0c45a7ab8b9f1a6aa63deda2acd8f111892411080fbb8d039ced27cb2fe20<br>  Stored <span class="hljs-keyword">in</span> directory: <br></code></pre></td></tr></table></figure><p>原因是没有下载SWIG</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo apt update<br>sudo apt <span class="hljs-keyword">install</span> swig<br></code></pre></td></tr></table></figure><p>检查是否安装成功</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">swig -<span class="hljs-built_in">version</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>强化学习环境配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>状态反馈和极点配置知识点总结</title>
    <link href="/2024/05/17/%E7%8A%B6%E6%80%81%E5%8F%8D%E9%A6%88%E5%92%8C%E6%9E%81%E7%82%B9%E9%85%8D%E7%BD%AE%E6%80%BB%E7%BB%93/"/>
    <url>/2024/05/17/%E7%8A%B6%E6%80%81%E5%8F%8D%E9%A6%88%E5%92%8C%E6%9E%81%E7%82%B9%E9%85%8D%E7%BD%AE%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>本文为对状态反馈和极点配置的知识点总结 <span id="more"></span> ###1、状态反馈和输出反馈</p><h4 id="状态反馈和输出反馈">1.1 状态反馈和输出反馈</h4><h5 id="状态反馈">(1)状态反馈</h5><p><span class="math inline">\(\dot{x} = Ax+Bu\)</span></p><p><span class="math inline">\(y=Cx\)</span></p><p>引入状态的线性反馈：<span class="math inline">\(u=v-Kx\)</span></p><figure><img src="/assets/image-20240426121853647.png"alt="image-20240426121853647" /><figcaption aria-hidden="true">image-20240426121853647</figcaption></figure><p>故: <span class="math display">\[\begin{equation}\begin{split}\dot{x}&amp;=Ax+B(v-Kx) \\&amp;=(A-BK)x+Bv\\y&amp;=Cx\\\end{split}\end{equation}\]</span> 故特征多项式：<spanclass="math inline">\(\alpha(s)=det(sI-A+BK)\)</span></p><p>传递函数矩阵：<spanclass="math inline">\(G_k(s)=C(sI-A+BK)^{-1}B\)</span></p><h5 id="输出反馈">(2)输出反馈</h5><figure><img src="/assets/image-20240426121831966.png"alt="image-20240426121831966" /><figcaption aria-hidden="true">image-20240426121831966</figcaption></figure><p>有： <span class="math display">\[\begin{equation}\begin{split}\dot{x}&amp;=Ax+Bu\\&amp;=Ax+B(v-Fy)\\&amp;=Ax+B(v-FCx)\\&amp;=(A-BFC)x+Bv\\y&amp;=Cx\end{split}\end{equation}\]</span> 特征多项式：<spanclass="math inline">\(\alpha(s)=det(sI-A+BFC)\)</span></p><p>传递函数矩阵:<spanclass="math inline">\(G_F(s)=C(sI-A+BFC)^{-1}B\)</span></p><h5 id="状态反馈和输出反馈的比较">(3)状态反馈和输出反馈的比较</h5><figure><img src="/assets/image-20240426120316441.png"alt="image-20240426120316441" /><figcaption aria-hidden="true">image-20240426120316441</figcaption></figure><p>对于反馈功能：输出反馈能完成的任务，状态反馈一定能完成；反之不一定。</p><h4 id="反馈结构对系统性能的影响">1.2 反馈结构对系统性能的影响</h4><h5 id="对于系统能控性和能观测性">(1)对于系统能控性和能观测性</h5><p><strong>结论</strong>：状态反馈不改变系统能控性，但可能改变系统的能观测性。</p><p>当闭环反馈系统出现零极点对消，被消去的极点便是不可观测的。</p><h5id="对系统稳定性只总结了状态反馈镇定">(2)对系统稳定性（只总结了状态反馈镇定）</h5><p>状态反馈和输出反馈都改变系统的特征值，从而影响系统的稳定性。</p><p>可镇定性：若采用反馈措施能使闭环系统稳定，则称该系统是反馈可镇定的。</p><h5 id="状态反馈镇定"><strong>状态反馈镇定</strong></h5><p>有线性定常受控系统：</p><p><span class="math inline">\(\dot{x}=Ax+Bu\)</span></p><p>有<span class="math inline">\(x(0)=x_0\)</span>，<spanclass="math inline">\(t \geq 0\)</span></p><p>若可以找到反馈状态控制律：<spanclass="math inline">\(u=v-Kx\)</span></p><p>使得构成的反馈闭环系统：<spanclass="math inline">\(\dot{x}=(A-BK)x+Bv\)</span>是渐进稳定的，即<spanclass="math inline">\((A-BK)\)</span>的特征值均具有负实部，则称系统实现了状态反馈镇定。</p><p>使线性定常系统状态反馈镇定（状态反馈闭环反馈系统稳定）的<strong>必要条件</strong>：该线性定常系统的不能控部分是渐进稳定的。</p><table><thead><tr class="header"><th>线性定常系统是否完全能控</th><th>线性定常系统不能控部分是否渐进稳定</th><th>其状态反馈是否为可镇定</th></tr></thead><tbody><tr class="odd"><td>是</td><td>无不能控部分</td><td>是</td></tr><tr class="even"><td>否</td><td>是（不能控部分极点均具有负实部）</td><td>是</td></tr><tr class="odd"><td>否</td><td>否（不能控部分极点具有非负实部）</td><td>否</td></tr></tbody></table><h3 id="状态反馈极点配置">2、状态反馈极点配置</h3><h5 id="极点配置问题的提法">2.1 极点配置问题的提法</h5><table><thead><tr class="header"><th>连续时间线性时不变系统反馈方式</th><th>能否任意配置系统的全部极点</th><th></th><th>能否配置能控部分的极点</th><th>能否配置不能控部分的极点</th></tr></thead><tbody><tr class="odd"><td>状态反馈</td><td>否</td><td></td><td>是</td><td>否</td></tr><tr class="even"><td>输出反馈</td><td>否</td><td></td><td>是</td><td>否</td></tr><tr class="odd"><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h6 id="状态反馈极点配置的提法">状态反馈极点配置的提法</h6><p>连续时间线性时不变系统<spanclass="math inline">\(\dot{x}=Ax+Bu\)</span></p><p>给定<strong><spanclass="math inline">\(n\)</span>个期望闭环极点</strong>（即特征值）<spanclass="math inline">\({\lambda^{*}_1，\lambda^{*}_2，···，\lambda^{*}_n}\)</span>，试确定状态反馈矩阵<spanclass="math inline">\(K\)</span>，使得所得到的状态反馈闭环控制系统</p><p><span class="math inline">\(\dot{x}=(A-BK)x+Bv\)</span></p><p>的特征值配置到期望极点处，即满足<spanclass="math inline">\(\lambda_i(A-BK)=\lambda_i^{*}，i=1，2，3，···，n\)</span></p><p>注：状态反馈<spanclass="math inline">\(K\)</span>不能改变不能控部分的极点，但能任意配置能控部分的极点</p><h5 id="单输入系统状态反馈极点配置">2.2 单输入系统状态反馈极点配置</h5><h6 id="利用状态反馈的极点可配置条件">2.2.1利用状态反馈的极点可配置条件</h6><p>结论1：利用<strong>状态反馈任意配置全部闭环极点</strong>（即特征值）的<strong>充分必要条件</strong>是被控系统完全能控。</p><p>结论2：如果系统不能控部分特征值属于期望闭环特征值，那仍能通过状态反馈配置系统的全部闭环极点。</p><p>对结论1的证明：以单输入-多输出系统来证明</p><p>​ 充分性(系统完全能控<spanclass="math inline">\(=&gt;\)</span>​状态反馈可任意配置闭环极点)证明：</p><p>​ 设系统<span class="math inline">\((A,b)\)</span>的特征多项式为：<span class="math display">\[\alpha(s)=det(sI-A)=s^n+\alpha_{n-1}^{n-1}s^{n-1}+···+\alpha_0\]</span> ​ 如果系统完全能控，则可通过非奇异线性变换<spanclass="math inline">\(\overline{x}=P^{-1}x\)</span>（即<spanclass="math inline">\(x=\overline{x}P\)</span>），将其变换为可控标准型：<span class="math display">\[\dot{\overline{x}}=\overline{A}\overline{x}+\overline{b}u\]</span></p><p><span class="math display">\[\begin{equation}\overline{A}=\begin{bmatrix}    0 &amp; 1 &amp; 0 &amp; \dots &amp; 0 \\    0 &amp; 0 &amp; 1 &amp; \ddots &amp; \vdots \\    \vdots &amp; \vdots &amp; \ddots &amp; \ddots &amp; 0 \\    0 &amp; 0 &amp; \dots &amp; 0 &amp; 1\\    -a_0 &amp; -a_1 &amp; -a_2 &amp;\dots &amp; -a_{n-1}\end{bmatrix};\overline{b}=P^{-1}b=\begin{bmatrix}0\\0\\\vdots\\0\\1\end{bmatrix}\end{equation}\]</span></p><p>​ 矩阵<spanclass="math inline">\(\overline{A}\)</span>对应的特征多项式(非奇异线性变换不改变原系统的特性)：<span class="math display">\[det[sI-\overline{A}]=det[sI-A]=s^n+a_{n-1}s^{n-1}+\dots+a_1s+a_0\]</span> ​ 设状态反馈矩阵： <span class="math display">\[\overline{k}=\begin{bmatrix}\overline{k}_1 &amp; \dots &amp; \overline{k}_n\end{bmatrix}\]</span> ​ 引入状态反馈后，闭环系统的状态方程为： <spanclass="math display">\[\dot{x}=(\overline{A}-\overline{b}K)x+\overline{b}v\]</span> ​ 引入状态反馈后，<spanclass="math inline">\((\overline{A}-\overline{b}K)\)</span>的特征多项式为：<span class="math display">\[det[sI-(\overline{A}-\overline{b}K)]=s^n+(a_{n-1}+\overline{k}_n)s^{n-1}+\dots+(a_{1-1}+\overline{k}_2)s+(a_{0}+\overline{k}_1)\tag{1}\]</span> ​ 设期望的闭环系统特征值为<spanclass="math inline">\(\lambda_1^*、\lambda_2^*、\dots、\lambda_{n}^*\)</span></p><p>​ 由期望闭环特征系统特征值确定的特征多项式： <spanclass="math display">\[\begin{equation}\begin{split}D(s)&amp;=(s-\lambda_1^*)(s-\lambda_2^*)\dots(s-\lambda_n^*)\\&amp;=s^n+a^*_{n-1}s^{n-1}+\dots+a^*_1s+a^*_0\end{split}\end{equation} \tag{2}\]</span> ​ 比较公式(1)和公式(2)可得： <span class="math display">\[\begin{equation}\left\{             \begin{array}{lr}             a_{n-1}+\overline{k}_n=a^*_{n-1}, &amp;  \\             \dots\\             a_{1}+\overline{k}_2=a^*_{1}, &amp;  \\             a_{0}+\overline{k}_1=a^*_{0}             \end{array}\right.\end{equation}\]</span> ​ 可解得： <span class="math display">\[\begin{equation}\left\{             \begin{array}{lr}             \overline{k}_n=a^*_{n-1}-a_{n-1}, &amp;  \\             \dots\\             \overline{k}_2=a^*_{1}-a_{1}, &amp;  \\             \overline{k}_1=a^*_{0}-a_{0}             \end{array}\right.\end{equation}\]</span> ​ 故状态反馈阵为： <span class="math display">\[\overline{k}=\begin{bmatrix}a^*_0-a_0 &amp; a^*_1a_1 &amp; \dots &amp; a^*_{n-1}-a_{n-1}  \end{bmatrix}\]</span> ​ 对于原系统来说引入状态反馈可得到： <spanclass="math display">\[u=v-kx=v-kP\overline{x}=v-\overline{k}\overline{x}\]</span> ​ 即对于原系统使得闭环极点配置到<spanclass="math inline">\(\lambda_1^*、\lambda_2^*、\dots、\lambda_{n}^*\)</span>的状态反馈矩阵：<span class="math display">\[k=\overline{k}P^{-1}\]</span> ​ 必要性(状态反馈可任意配置闭环极点<spanclass="math inline">\(=&gt;\)</span>系统完全能控)证明：</p><p>​ 反证法：反设系统不完全能控，则不能控部分的状态不受输入<spanclass="math inline">\(u\)</span>的影响与控制，引入状态反馈就不能通过控制<spanclass="math inline">\(k\)</span>来改变不可控极点</p><h5 id="单输入系统的极点配置算法">2.3 单输入系统的极点配置算法</h5><p>对给定<span class="math inline">\(n\)</span>维受控系统<spanclass="math inline">\((A,b)\)</span>和一组任意期望闭环特征值<spanclass="math inline">\(\lambda_1^*、\lambda_2^*、\dots、\lambda_{n}^*\)</span>，确定反馈增益矩阵<spanclass="math inline">\(k\)</span>，使得闭环系统矩阵<spanclass="math inline">\((A-bk)\)</span>的特征值为<spanclass="math inline">\(\lambda_1^*、\lambda_2^*、\dots、\lambda_{n}^*\)</span></p><h6 id="系数比较法">2.3.1 系数比较法</h6><table><thead><tr class="header"><th>步骤</th><th>关键公式</th></tr></thead><tbody><tr class="odd"><td>(1)计算期望特征多项式</td><td><spanclass="math inline">\(\alpha^*(s)=(s-\lambda^*_1)\dots(s-\lambda^*_n)\\=(s^n+\alpha^*_{n-1}s^{n-1}+\dots+\alpha^*_1s+\alpha^*_0)\)</span></td></tr><tr class="even"><td>(2)设<span class="math inline">\(k=\begin{bmatrix}k_1 &amp; k_2&amp;\dots&amp;k_n\end{bmatrix}\)</span>，用待定系数表示闭环系统的特征多项式</td><td><spanclass="math inline">\(alpha^(s)=det(sI-A+bk)\\=(s^n+\alpha_{n-1}s^{n-1}+\dots+\alpha_1s+\alpha_0)\)</span></td></tr><tr class="odd"><td>(3)由上述两式得到方程组，解方程得到<spanclass="math inline">\(k\)</span>矩阵中的元素</td><td><spanclass="math inline">\(\begin{equation}\left\{           \begin{array}{lr}            a_{n-1}=a^*_{n-1},&amp;  \\             \dots\\           a_{1}=a^*_{1},&amp;  \\             a_{0}+=a^*_{0}           \end{array}\right.\end{equation}\)</span></td></tr></tbody></table><p>2.3.2 完全能控单输入系统状态反馈极点配置的规范算法</p><table><thead><tr class="header"><th>步骤</th><th>关键公式</th></tr></thead><tbody><tr class="odd"><td>(1)计算矩阵A的特征多项式</td><td><spanclass="math inline">\(\alpha(s)=det(sI-A)\\=(s^n+\alpha_{n-1}s^{n-1}+\dots+\alpha_1s+\alpha_0)\)</span></td></tr><tr class="even"><td>(2)计算期望特征多项式</td><td><spanclass="math inline">\(\alpha^*(s)=(s-\lambda^*_1)\dots(s-\lambda^*_n)\\=(s^n+\alpha^*_{n-1}s^{n-1}+\dots+\alpha^*_1s+\alpha^*_0)\)</span></td></tr><tr class="odd"><td>(3)计算能控规范型反馈矩阵<spanclass="math inline">\(\overline{k}\)</span></td><td><spanclass="math inline">\(k=\begin{bmatrix}\alpha^*_0-\alpha_0&amp;\alpha^*_1-\alpha_1&amp;\dots&amp;\alpha^*_{n-1}-\alpha_{n-1}\end{bmatrix}\)</span></td></tr><tr class="even"><td>(4)计算非奇异变换矩阵<span class="math inline">\(P\)</span></td><td><span class="math inline">\(P=\begin{bmatrix}A^{n-1}b &amp;\dots&amp; Ab  &amp; b\end{bmatrix}\begin{bmatrix}1 &amp;\dots&amp;0 &amp;0\\\alpha_{n-1} &amp; 1 &amp; \dots &amp; 0\\\vdots &amp; \vdots &amp;\ddots &amp; \vdots\\\alpha_{1}&amp;\dots &amp;\alpha_{n-1}&amp;1\end{bmatrix}(左下三角)\\\)</span><spanclass="math inline">\(=\begin{bmatrix}b &amp; Ab &amp; \dots &amp;A^{n-1}b\end{bmatrix}\begin{bmatrix}1 &amp;\dots&amp;0 &amp;0\\\alpha_{n-1} &amp; 1 &amp; \dots &amp; 0\\\vdots &amp; \vdots &amp;\ddots &amp; \vdots\\\alpha_{1}&amp;\dots &amp;\alpha_{n-1}&amp;1\end{bmatrix}^T(左上三角)\)</span></td></tr><tr class="odd"><td>(5)计算<span class="math inline">\(P^{-1}\)</span></td><td><spanclass="math inline">\(P^{-1}=\frac{adj{P}}{det(P)}\)</span></td></tr><tr class="even"><td>(6)计算原系统的反馈增益阵</td><td><span class="math inline">\(k=\overline{k}P^{-1}\)</span></td></tr></tbody></table><h5 id="状态反馈堆传递函数矩阵的影响">2.3状态反馈堆传递函数矩阵的影响</h5><p>结论：</p><table style="width:100%;"><thead><tr class="header"><th>系统</th><th>结论</th><th></th></tr></thead><tbody><tr class="odd"><td>单输入单输出线性定常系统</td><td>结论： 对<strong>完全能控</strong><spanclass="math inline">\(n\)</span>维<strong>单输入单输出线性时不变系统</strong>，引入状态反馈任意配置闭环系统传递函数极点的同时，<strong>零点一般不发生改变</strong>（如果状态反馈将<strong>闭环系统极点配置为与零点相重合</strong>，会产生<strong>对消</strong>零点的情况）</td><td></td></tr><tr class="even"><td>多输入多输出线性定常系统</td><td>结论：对<strong>完全能控的多输入多输出线性定常系统</strong>，<strong>状态反馈</strong>在<strong>配置</strong>传递函数矩阵<strong>全部<spanclass="math inline">\(n\)</span>个极点</strong>的同时，<strong>一般不影响传递函数的零点</strong></td><td></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>控制理论</category>
      
      <category>现代控制理论学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>现代控制理论</tag>
      
      <tag>状态反馈</tag>
      
      <tag>极点配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>坐标变换旋转矩阵、四元数反解欧拉角公式推导</title>
    <link href="/2024/05/17/%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/"/>
    <url>/2024/05/17/%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<p>本文为对旋转矩阵的推导 <span id="more"></span></p><h1id="坐标变换旋转矩阵四元数反解欧拉角公式推导">坐标变换旋转矩阵、四元数反解欧拉角公式推导</h1><p><strong>author: LiaoYF</strong></p><p>(以下内容带有很多我个人的理解，仅供参考，有错误的话也请指出)</p><p>本文中，以右手螺旋定则判断旋转角度的正负。</p><h2 id="右手系的坐标系">右手系的坐标系</h2><p>一般的右手系定义中，大拇指指向是<spanclass="math inline">\(OZ\)</span>轴，四指指向是<spanclass="math inline">\(OX\)</span>轴，四指自然弯曲，从<spanclass="math inline">\(OX\)</span>轴绕<spanclass="math inline">\(OZ\)</span>轴向四指弯曲方向旋转90°是<spanclass="math inline">\(OY\)</span>轴。</p><p>故无论<span class="math inline">\(X、Y、Z\)</span>三轴朝向怎样，<spanclass="math inline">\(X、Y、Z\)</span>三轴相对位置关系是一定的，所以当以一轴为旋转轴，对于剩下的二轴所在的二维平面来说旋转矩阵的形式是一定的。</p><p>假设旋转前的坐标系为<spanclass="math inline">\(a\)</span>,旋转后的坐标系为<spanclass="math inline">\(b\)</span>，该平面上有一点<spanclass="math inline">\(P\)</span>，则容易得到向量在<spanclass="math inline">\(b\)</span>系下的坐标数值大小等于将<spanclass="math inline">\(\overrightarrow{OP}\)</span>保持模长不变沿着反方向旋转相同角度在<spanclass="math inline">\(a\)</span>系下的坐标数值。与复数相乘具有几何意义，具体见下文。所以可用与复数相乘相似的方式来简单地推导出下列三个表达式。</p><h2 id="一二维平面的旋转矩阵">一、二维平面的旋转矩阵</h2><h3 id="xoy平面上的坐标系进行旋转">1、<spanclass="math inline">\(XOY\)</span>平面上的坐标系进行旋转</h3><p><spanclass="math inline">\(XOY\)</span>平面上的坐标系进行旋转,是绕垂直于<spanclass="math inline">\(XOY\)</span>平面的轴旋转的，假设这个轴方向与右手系中的<spanclass="math inline">\(OZ\)</span>轴方向（在图1.1中垂直于<spanclass="math inline">\(XOY\)</span>平面向外）相同且过坐标原点，旋转角度为<spanclass="math inline">\(\theta\)</span>。</p><figure><img src="/assets/坐标系xoy.png" alt="坐标系xoy" /><figcaption aria-hidden="true">坐标系xoy</figcaption></figure><p>​ 图1.1</p><p>假设<span class="math inline">\(Y\)</span>轴是虚轴，<spanclass="math inline">\(X\)</span>轴是实轴，复数<spanclass="math inline">\(Z_1 = x_{ap}+iy_{ap}\)</span>，复数<spanclass="math inline">\(Z_2 = x_{bp}+iy_{bp}\)</span>，复数<spanclass="math inline">\(Z_3 =e^{i(-\theta)}=cos\theta-isin\theta\)</span>。</p><p>可由与复数相乘的几何意义得到下列式子1.1.2： <spanclass="math display">\[Z_2=Z_1Z_3 \tag{1.1.1}\]</span></p><p><span class="math display">\[x_{bp}+iy_{bp}=(x_{ap}cos\theta+y_{ap}sin\theta) +i(-x_{ap}sin\theta+y_{ap}cos\theta) \tag{1.1.2}\]</span></p><p>可得到下列公式1.3 <span class="math display">\[\left[\begin{array}{ccc}     x_{bp} \\     y_{bp} \\\end{array}\right]        =\left[\begin{array}{ccc}     cos\theta &amp; sin\theta  \\     -sin\theta&amp; cos\theta \\\end{array}\right]        \left[\begin{array}{ccc}     x_{ap} \\     y_{ap} \\\end{array}\right]        \tag{1.1.3}\]</span></p><h3 id="xoz平面上的坐标系进行旋转">2、<spanclass="math inline">\(XOZ\)</span>平面上的坐标系进行旋转</h3><p><spanclass="math inline">\(XOZ\)</span>平面上的向量旋转，是绕垂直于<spanclass="math inline">\(XOZ\)</span>平面的轴旋转的，假设这个轴方向与右手系中的<spanclass="math inline">\(Y\)</span>轴方向（在图1.2中垂直于<spanclass="math inline">\(XOZ\)</span>平面向外）相同，旋转角度为<spanclass="math inline">\(\theta\)</span></p><figure><img src="/assets/坐标系xoz.png" alt="坐标系xoz" /><figcaption aria-hidden="true">坐标系xoz</figcaption></figure><p>​ 图1.2</p><p>假设X轴是虚轴，<spanclass="math inline">\(Z\)</span>轴是实轴，复数<spanclass="math inline">\(Z_1 = z_{ap}+ix_{ap}\)</span>，复数<spanclass="math inline">\(Z_2 = z_{bp}+ix_{bp}\)</span>，复数<spanclass="math inline">\(Z_3 =e^{i(-\theta)}=cos\theta-isin\theta\)</span>。</p><p>可由与复数相乘的几何意义得到下列式子1.2.1： <spanclass="math display">\[Z_2=Z_1Z_3\]</span></p><p><span class="math display">\[z_{bp}+ix_{bp}=(z_{ap}cos\theta+x_{ap}sin\theta) +i(-z_{ap}sin\theta+x_{ap}cos\theta) \tag{1.2.1}\]</span></p><p>可得到下列公式1.5 <span class="math display">\[\left[\begin{array}{ccc}     x_{bp} \\     Z_{bp} \\\end{array}\right]        =\left[\begin{array}{ccc}     cos\theta &amp; -sin\theta  \\     sin\theta&amp; cos\theta \\\end{array}\right]        \left[\begin{array}{ccc}     x_{ap} \\     Z_{ap} \\\end{array}\right]        \tag{1.2.2}\]</span></p><h3 id="yoz平面上的坐标系进行旋转">3、<spanclass="math inline">\(YOZ\)</span>平面上的坐标系进行旋转</h3><p><spanclass="math inline">\(YOZ\)</span>平面上的向量旋转，是绕垂直于<spanclass="math inline">\(YOZ\)</span>平面的轴旋转的，假设这个轴方向与右手系中的<spanclass="math inline">\(X\)</span>轴方向（在图1.3中垂直于<spanclass="math inline">\(YOZ\)</span>平面向外）相同，旋转角度为<spanclass="math inline">\(\theta\)</span></p><figure><img src="/assets/坐标系yoz.png" alt="坐标系yoz" /><figcaption aria-hidden="true">坐标系yoz</figcaption></figure><p>​ 图1.3</p><p>假设Z轴是虚轴，Y轴是实轴，复数<span class="math inline">\(Z_1 =y_{ap}+iz_{ap}\)</span>，复数<span class="math inline">\(Z_2 =y_{bp}+iz_{bp}\)</span>，复数<span class="math inline">\(Z_3 =e^{i(-\theta)}=cos\theta-isin\theta\)</span>。</p><p>可由与复数相乘的几何意义得到下列式子1.3.1： <spanclass="math display">\[Z_2=Z_1Z_3\]</span></p><p><span class="math display">\[y_{bp}+iz_{bp}=(y_{ap}cos\theta+z_{ap}sin\theta) +i(-y_{ap}sin\theta+z_{ap}cos\theta) \tag{1.3.1}\]</span></p><p>可得到下列公式1.7 <span class="math display">\[\left[\begin{array}{ccc}     y_{bp} \\     Z_{bp} \\\end{array}\right]        =\left[\begin{array}{ccc}     cos\theta &amp; sin\theta  \\     -sin\theta&amp; cos\theta \\\end{array}\right]        \left[\begin{array}{ccc}     y_{ap} \\     Z_{ap} \\\end{array}\right]        \tag{1.3.2}\]</span></p><h2 id="二三维坐标系的旋转矩阵">二、三维坐标系的旋转矩阵</h2><figure><img src="/assets/三维旋转_完整.png" alt="三维旋转_完整" /><figcaption aria-hidden="true">三维旋转_完整</figcaption></figure><p>​ 图2.1</p><h3 id="本文所使用的三维坐标系假设">1、本文所使用的三维坐标系假设</h3><p>设坐标系<spanclass="math inline">\(OX_aY_aZ_a\)</span>为固定坐标系，坐标系<spanclass="math inline">\(b\)</span>是动坐标系。设坐标系<spanclass="math inline">\(b\)</span>起始位置（<spanclass="math inline">\(OX_bY_bZ_b\)</span>）与坐标系<spanclass="math inline">\(OX_aY_aZ_a\)</span>三轴方向平行，且坐标原点重合，坐标系<spanclass="math inline">\(b\)</span>旋转之后为<spanclass="math inline">\(OX_b^{&#39;&#39;}Y_b^{&#39;&#39;}Z_b^{&#39;&#39;}\)</span>坐标系。假设坐标系<spanclass="math inline">\(OX_aY_aZ_a\)</span>为三轴正交的坐标系，朝前是<spanclass="math inline">\(X_a\)</span>轴，朝右是<spanclass="math inline">\(Y_a\)</span>轴，朝上是<spanclass="math inline">\(Z_a\)</span>轴。如图2.1所示，故可设任意时刻坐标系<spanclass="math inline">\(b\)</span>相对于旋转轴旋转欧拉姿态角<spanclass="math inline">\(\psi、\theta、\phi\)</span>（当<spanclass="math inline">\(OX_aY_aZ_a\)</span>为地理坐标系，坐标系<spanclass="math inline">\(b\)</span>为机体坐标系时，这三个角度分别对应航向角、俯仰角、横滚角），<spanclass="math inline">\(ON\)</span>轴表示坐标系<spanclass="math inline">\(b\)</span>第一次绕<spanclass="math inline">\(OZ_a(OZ_b)\)</span>轴旋转之后的<spanclass="math inline">\(X_b&#39;\)</span>轴。</p><h3 id="旋转顺序">2、旋转顺序</h3><p>一般从固定坐标到动坐标系到动坐标系需要经过三次旋转，每次旋转之后绕不同的轴再进行一次旋转。需满足每次旋转之后，绕旋转轴的角度能和欧拉角相匹配。</p><p>所以在“1、本文所使用的三维坐标系假设”条件下，应选择的旋转顺序为固定坐标系的<spanclass="math inline">\(Z-&gt;Y-&gt;X\)</span>，即先绕<spanclass="math inline">\(OZ_a(OZ_b)\)</span>轴旋转<spanclass="math inline">\(\psi\)</span>，再绕<spanclass="math inline">\(OY_b&#39;\)</span>轴旋转<spanclass="math inline">\(\theta\)</span>，最后绕<spanclass="math inline">\(OX_b&#39;&#39;\)</span>轴旋转<spanclass="math inline">\(\phi\)</span>。</p><h3 id="旋转矩阵推导">3、旋转矩阵推导</h3><p>已知：三坐标轴相互垂直的正交坐标系间相互变换的旋转矩阵为正交矩阵<spanclass="math inline">\(R(\theta)\)</span>，满足<spanclass="math inline">\(R(\theta)^{-1} = R(\theta)^{T}\)</span></p><p>设空间中存在一点<span class="math inline">\(P\)</span>，在坐标系<spanclass="math inline">\(OX_aY_aZ_a\)</span>中可表示为<spanclass="math inline">\(P(x_{ap},y_{ap},z_{ap})\)</span>，在旋转之后的坐标系<spanclass="math inline">\(OX_b^{&#39;&#39;}Y_b^{&#39;&#39;}Z_b^{&#39;&#39;}\)</span>中可表示为<spanclass="math inline">\(P(x^{&#39;&#39;}_{bp},y^{&#39;&#39;}_{bp},z^{&#39;&#39;}_{bp})\)</span></p><h4 id="第1次旋转">（1）第1次旋转</h4><p>设坐标系<span class="math inline">\(b\)</span>第一次绕<spanclass="math inline">\(OZ_a(OZ_b)\)</span>轴旋转<spanclass="math inline">\(\psi\)</span>之后的坐标系是<spanclass="math inline">\(OX_{b}&#39;Y_b&#39;Z_b\)</span></p><figure><img src="/assets/三维旋转_第一次.png" alt="三维旋转_第一次" /><figcaption aria-hidden="true">三维旋转_第一次</figcaption></figure><pre><code class="hljs">                    图2.2</code></pre><p><span class="math display">\[\left[\begin{array}{ccc}     x^{&#39;}_{bp} \\     y^{&#39;}_{bp} \\     z_{ap}\end{array}\right]        =\left[\begin{array}{ccc}     cos\psi &amp; sin\psi &amp; 0 \\     -sin\psi&amp; cos\psi &amp; 0\\     0       &amp;    0      &amp; 1\end{array}\right]        \left[\begin{array}{ccc}     x_{ap} \\     y_{ap} \\     z_{ap}\end{array}\right]        \tag{2.3.1}\]</span></p><p><span class="math display">\[R_z = \left[\begin{array}{ccc}     cos\psi &amp; sin\psi &amp; 0 \\     -sin\psi&amp; cos\psi &amp; 0\\     0       &amp;    0      &amp; 1\end{array}\right]   \tag{2.3.2}\]</span></p><h4 id="第2次旋转">（2）第2次旋转</h4><p>设坐标系<span class="math inline">\(b\)</span>第2次绕<spanclass="math inline">\(OY^{&#39;}_b\)</span>轴旋转<spanclass="math inline">\(\theta\)</span>之后的坐标系是<spanclass="math inline">\(OX^{&#39;&#39;}_{b}Y^{&#39;}_bZ^{&#39;}_b\)</span></p><figure><img src="/assets/三维旋转_第二次.png" alt="三维旋转_第二次" /><figcaption aria-hidden="true">三维旋转_第二次</figcaption></figure><p>​ 图2.3 <span class="math display">\[\left[\begin{array}{ccc}     x^{&#39;&#39;}_{bp} \\     y^{&#39;}_{bp} \\     z^{&#39;}_{bp}\end{array}\right]        =\left[\begin{array}{ccc}     cos\theta &amp; 0&amp; -sin\theta \\     0 &amp; 1 &amp; 0\\     sin\theta&amp; 0 &amp; cos\theta\end{array}\right]        \left[\begin{array}{ccc}     x^{&#39;}_{bp} \\     y^{&#39;}_{bp} \\     z_{ap}\end{array}\right]        \tag{2.3.3}\]</span></p><p><span class="math display">\[R_y=\left[\begin{array}{ccc}     cos\theta &amp; 0&amp; -sin\theta \\     0 &amp; 1 &amp; 0\\     sin\theta&amp; 0 &amp; cos\theta\end{array}\right] \tag{2.3.4}\]</span></p><h4 id="第3次旋转">（3）第3次旋转</h4><p>设坐标系<span class="math inline">\(b\)</span>第3次绕<spanclass="math inline">\(OX^{&#39;&#39;}_b\)</span>轴旋转<spanclass="math inline">\(\phi\)</span>之后的坐标系是<spanclass="math inline">\(OX^{&#39;&#39;}_{b}Y^{&#39;&#39;}_bZ^{&#39;&#39;}_b\)</span></p><figure><img src="/assets/三维旋转_第三次.png" alt="三维旋转_第三次" /><figcaption aria-hidden="true">三维旋转_第三次</figcaption></figure><p>​ 图2.4 <span class="math display">\[\left[\begin{array}{ccc}     x^{&#39;&#39;}_{bp} \\     y^{&#39;&#39;}_{bp} \\     z^{&#39;&#39;}_{bp}\end{array}\right]        =\left[\begin{array}{ccc}     1       &amp; 0 &amp; 0\\     0 &amp; cos\phi &amp; sin\phi \\     0 &amp; -sin\phi &amp; cos\phi\end{array}\right]        \left[\begin{array}{ccc}     x^{&#39;&#39;}_{bp} \\     y^{&#39;}_{bp} \\     z^{&#39;}_{bp}\end{array}\right]        \tag{2.3.5}\]</span></p><p><span class="math display">\[R_x=\left[\begin{array}{ccc}     1       &amp; 0 &amp; 0\\     0 &amp; cos\phi &amp; sin\phi \\     0 &amp; -sin\phi &amp; cos\phi\end{array}\right]  \tag{2.3.6}\]</span></p><h4 id="坐标系ox_ay_az_a到坐标系ox_by_bz_b的旋转矩阵">（4）坐标系<spanclass="math inline">\(OX_aY_aZ_a\)</span>到坐标系<spanclass="math inline">\(OX_b^{&#39;&#39;}Y_b^{&#39;&#39;}Z_b^{&#39;&#39;}\)</span>的旋转矩阵</h4><p><span class="math display">\[\left[\begin{array}{ccc}     x^{&#39;&#39;}_{bp} \\     y^{&#39;&#39;}_{bp} \\     z^{&#39;&#39;}_{bp}\end{array}\right] = C^b_a \left[\begin{array}{ccc}     x_{ap} \\     y_{ap} \\     z_{ap}\end{array}\right]\]</span></p><p><span class="math display">\[C^b_a= R_xR_yR_z \tag{2.3.7}\]</span></p><p><span class="math display">\[\begin{flalign}C^b_a &amp;= \begin{bmatrix}cos (\psi )cos (\theta ) &amp; cos (\theta )sin (\psi ) &amp; -sin(\theta )\\cos (\psi )sin (\phi )sin (\theta )-cos (\phi )sin (\psi ) &amp; cos(\phi )cos (\psi )+sin (\phi )sin (\psi )sin (\theta ) &amp; cos (\theta)sin (\phi )\\sin (\phi )sin (\psi )+cos (\phi )cos (\psi )sin (\theta ) &amp; cos(\phi )sin (\psi )sin (\theta )-cos (\psi )sin (\phi ) &amp; cos (\phi)cos (\theta )\end{bmatrix}\end{flalign} \tag{2.3.8}\]</span></p><h4id="坐标系ox_by_bz_b到坐标系坐标系ox_ay_az_a的旋转矩阵">（5）坐标系<spanclass="math inline">\(OX_b^{&#39;&#39;}Y_b^{&#39;&#39;}Z_b^{&#39;&#39;}\)</span>到坐标系坐标系<spanclass="math inline">\(OX_aY_aZ_a\)</span>的旋转矩阵</h4><p><span class="math display">\[\left[\begin{array}{ccc}     x_{ap} \\     y_{ap} \\     z_{ap}\end{array}\right] = C^a_b\left[\begin{array}{ccc}     x^{&#39;&#39;}_{bp} \\     y^{&#39;&#39;}_{bp} \\     z^{&#39;&#39;}_{bp}\end{array}\right]\]</span></p><p><span class="math display">\[C^a_b= {(C^b_a)}^{(-1)}={(C^b_a)}^{T}=R^T_zR^T_yR^T_x\tag{2.3.9}\]</span></p><p>(此处公式超出界面了，之后会解决，抱歉) <span class="math display">\[C^a_b=\left[\begin{array}{ccc}\cos \left({\psi} \right)\cos \left({\theta} \right) &amp; \cos\left({\psi} \right)sin \left({\phi} \right)sin \left({\theta}\right)-\cos \left({\phi} \right)sin \left({\psi} \right) &amp; sin\left({\phi} \right)sin \left({\psi} \right)+\cos \left({\phi}\right)\cos \left({\psi} \right)sin \left({\theta} \right)\\\cos \left({\theta} \right)sin \left({\psi} \right) &amp; \cos\left({\phi} \right)\cos \left({\psi} \right)+sin \left({\phi}\right)sin \left({\psi} \right)sin \left({\theta} \right) &amp; \cos\left({\phi} \right)sin \left({\psi} \right)sin \left({\theta}\right)-\cos \left({\psi} \right)sin \left({\phi} \right)\\-sin \left({\theta} \right) &amp; \cos \left({\theta} \right)sin\left({\phi} \right) &amp; \cos \left({\phi} \right)\cos \left({\theta}\right)\end{array}\right]\tag{2.3.10}\]</span></p><h2 id="三欧拉角表示旋转的缺陷">三、欧拉角表示旋转的缺陷</h2><p>欧拉角表示旋转存在万向锁问题</p><p>仍然以“二”中假设的坐标系为例，用欧拉角表示旋转时第2次旋转时<spanclass="math inline">\(|\theta|\)</span>不能等于90°，下面以欧拉角的微分方程推导来说明原因。</p><p>假设坐标系<span class="math inline">\(b\)</span>相对于坐标系<spanclass="math inline">\(OX_aY_aZ_a\)</span>的角速度分别为<strong><spanclass="math inline">\(\dot{\psi}\)</span>、<spanclass="math inline">\(\dot{\theta}\)</span>、<spanclass="math inline">\(\dot{\phi}\)</span></strong>，假设这三个角速度矢量在坐标系<spanclass="math inline">\(b\)</span>最终位置坐标系<spanclass="math inline">\(OX_b^{&#39;&#39;}Y_b^{&#39;&#39;}Z_b^{&#39;&#39;}\)</span>的轴向分量分别为<spanclass="math inline">\(\omega_{zb}、\omega_{yb}、\omega_{xb}\)</span></p><p>在坐标系<spanclass="math inline">\(b\)</span>从初始位置旋转到坐标系<spanclass="math inline">\(OX_b^{&#39;&#39;}Y_b^{&#39;&#39;}Z_b^{&#39;&#39;}\)</span>的过程中：</p><p>进行第1次旋转后，得到了<spanclass="math inline">\(\dot{\psi}\)</span>，将其转换为<spanclass="math inline">\(\omega_{zb}\)</span>，还需最后2次的旋转矩阵来做变换：<span class="math display">\[\left[\begin{array}{ccc}     0 \\     0 \\     \omega_{zb}\end{array}\right] = R_xR_y\left[\begin{array}{ccc}     0 \\     0 \\     \dot{\psi}\end{array}\right] \tag{3.1}\]</span> 进行第2次旋转时,得到了<spanclass="math inline">\(\dot{\theta}\)</span>，还需使用第3次的旋转矩阵来进行角速度的变换：<span class="math display">\[\left[\begin{array}{ccc}     0 \\     \omega_{yb} \\     0\end{array}\right] = R_x\left[\begin{array}{ccc}     0 \\     \dot{\theta} \\     0\end{array}\right]\tag{3.2}\]</span> 进行第3次旋转时,容易得到： <span class="math display">\[\omega_{xb}= \dot{\phi} \tag{3.3}\]</span> 由式3.1、3.2、3.3可得： <span class="math display">\[\left[\begin{array}{ccc}     \omega_{xb} \\     \omega_{yb}\\     \omega_{zb}\end{array}\right] = \left[\begin{array}{c}{\dot{\phi}} -sin \left(\theta \right)\,\dot{\psi} \\\cos \left(\phi \right)\,\dot{\theta} +\cos \left(\theta \right)\,sin\left(\phi \right)\,\dot{\psi} \\\cos \left(\phi \right)\,\cos \left(\theta \right)\,\dot{\psi} -sin\left(\phi \right)\,\dot{\theta}\end{array}\right]\]</span></p><p><span class="math display">\[\left[\begin{array}{ccc}     \omega_{xb} \\     \omega_{yb}\\     \omega_{zb}\end{array}\right] = \left[\begin{array}{ccc}     1 &amp; 0 &amp; -sin{(\theta)}\\     0 &amp; \cos{(\phi)} &amp; \cos{(\theta)} sin{(\phi)}\\     0 &amp; -sin{(\phi)} &amp; \cos{(\phi)}\cos{(\theta)}\end{array}\right] \left[\begin{array}{ccc}     \dot{\phi} \\     \dot{\theta}\\     \dot{\psi}\end{array}\right] \tag{3.4}\]</span></p><p><span class="math display">\[\left[\begin{array}{ccc}     \dot{\phi} \\     \dot{\theta}\\     \dot{\psi}\end{array}\right]= \left[\begin{array}{ccc}     1 &amp; 0 &amp; -sin{(\theta)}\\     0 &amp; \cos{(\phi)} &amp; \cos{(\theta)} sin{(\phi)}\\     0 &amp; -sin{(\phi)} &amp; \cos{(\phi)}\cos{(\theta)}\end{array}\right]^{-1} \left[\begin{array}{ccc}     \omega_{xb} \\     \omega_{yb}\\     \omega_{zb}\end{array}\right]\]</span></p><p>故可得： <span class="math display">\[\left[\begin{array}{ccc}     \dot{\phi} \\     \dot{\theta}\\     \dot{\psi}\end{array}\right]= \frac{1}{\cos{\theta}}\left[\begin{array}{ccc}     \cos{(\theta)} &amp; sin{(\phi)}sin{(\theta)} &amp;\cos{(\phi)}sin{(\theta)} \\     0 &amp; \cos{(\phi)}\cos{(\theta)} &amp;-sin{(\phi)}\cos{(\theta)}\\     0 &amp; sin{(\phi)} &amp; \cos{(\phi)}\end{array}\right] \left[\begin{array}{ccc}     \omega_{xb} \\     \omega_{yb}\\     \omega_{zb}\end{array}\right] \tag{3.5}\]</span> 由方程3.5可得，<spanclass="math inline">\(|\theta|\)</span>等于<spanclass="math inline">\(90°\)</span>时，方程出现奇点。</p><h2 id="四四元数表示旋转">四、四元数表示旋转</h2><h3id="二维复平面中与复数reibeta相乘的几何意义">1、二维复平面中，与复数<spanclass="math inline">\(re^{i\beta}\)</span>相乘的几何意义</h3><p>设二维复平面中的一个复数<spanclass="math inline">\(r_{1}e^{i\beta}\)</span>，其对应的经过坐标原点的向量为$<span class="math inline">\(，\)</span>r_{1}e<sup>{i}<spanclass="math inline">\(与\)</span>re</sup>{i}<spanclass="math inline">\(相乘意味着，\)</span> <spanclass="math inline">\(模长变为原来的\)</span>r<spanclass="math inline">\(倍，且绕坐标原点旋转\)</span>$角度</p><h3 id="四元数相乘也具有几何意义">2、四元数相乘也具有几何意义</h3><p>假设一个纯四元数<span class="math inline">\(\hat{P} =(0,p_x,p_y,p_y)\)</span>，其可对应在三维空间中的一个向量。假设一个单位四元数<spanclass="math inline">\(\hat{q}=(q_0,q_1,q_2,q_3)，q_0\)</span>代表实部。对于四元数有 <span class="math display">\[q^{-}=\frac{q^{*}}{|q|} \tag{4.2.1}\]</span> 对于单位四元数有: <span class="math display">\[|q|=1 \tag{4.2.2}\]</span> 故对单位四元数有： <span class="math display">\[q^{-}=q^{*} \tag{4.2.3}\]</span></p><h4 id="轴角表示旋转与四元数的关系">（1）轴角表示旋转与四元数的关系</h4><p>假设一个以单位向量定义的旋转轴<spanclass="math inline">\(\hat{u}=(ux,uy,uz)\)</span>，点<spanclass="math inline">\(v\)</span>的坐标<spanclass="math inline">\((0,x_v,y_v,z_v)\)</span>以该旋转轴右手系方向旋转<spanclass="math inline">\(\alpha\)</span>角度后变为点<spanclass="math inline">\(v&#39;\)</span>，<spanclass="math inline">\(\hat{q}=(q_0,q_1,q_2,q_3)\)</span>为单位四元数，有以下关系式：<span class="math display">\[\hat{v&#39;}=\hat{q}\hat{v}\hat{q}^{-}=\hat{q}\hat{v}\hat{q}^{*}\tag{4.2.4}\]</span> 其中： <span class="math display">\[\hat{q}=(\cos\frac{\alpha}{2},\overrightarrow{u} sin\frac{\alpha}{2})\tag{4.2.5}\]</span></p><h4 id="四元数表示旋转矩阵">（2）四元数表示旋转矩阵</h4><p>将式4.2.4利用四元数乘法展开可得到四元数表示的旋转矩阵： <spanclass="math display">\[\begin{equation}\begin{split}\begin{bmatrix}     x^{&#39;}_v \\     y^{&#39;}_v\\     z^{&#39;}_v\end{bmatrix}&amp;=\begin{bmatrix}     1-2(q_2^2+q_3^2) &amp; 2(q_1q_2-q_0q_3) &amp; 2(q_1q_3+q_0q_2) \\     2(q_1q_2+q_0q_3) &amp; 1-2(q_1^2+q_3^2) &amp; 2(q_2q_3-q_0q_1) \\     2(q_1q_3-q_0q_2)  &amp; 2(q_2q_3+q_0q_1) &amp; 1-2(q_1^2+q_2^2)   \end{bmatrix}\begin{bmatrix}     x_v \\     y_v\\     z_v\end{bmatrix}\end{split}\end{equation} \tag{4.2.5}\]</span> 其中： <span class="math display">\[q_0=\cos\frac{\alpha}{2},q_1=u_x sin\frac{\alpha}{2},q_2=u_ysin\frac{\alpha}{2},q_3=u_z sin\frac{\alpha}{2}  \tag{4.2.6}\]</span> 四元数旋转矩阵如下： <span class="math display">\[R = \left[\begin{array}{ccc}     1-2(q_2^2+q_3^2) &amp; 2(q_1q_2-q_0q_3) &amp; 2(q_1q_3+q_0q_2) \\     2(q_1q_2+q_0q_3) &amp; 1-2(q_1^2+q_3^2) &amp; 2(q_2q_3-q_0q_1) \\     2(q_1q_3-q_0q_2)  &amp; 2(q_2q_3+q_0q_1) &amp; 1-2(q_1^2+q_2^2)   \end{array} \right] \tag{4.2.7}\]</span></p><h4 id="四元数反解欧拉角">（3）四元数反解欧拉角</h4><p>当式4.2.7的旋转矩阵代表的是动坐标系到固定坐标系的旋转，且坐标系方向、角度定义与“二”中相同时，可通过与式2.3.10相比较，计算得到欧拉角大小。<span class="math display">\[\frac{(C^a_{b})_{32}}{(C^a_{b})_{33}}=\tan\phi=\frac{b_{32}}{b_{33}}\\(C^a_{b})_{31}=sin(-\theta) =b_{31}\\\frac{(C^a_{b})_{21}}{(C^a_{b})_{11}}=\tan\psi=\frac{b_{21}}{b_{11}}\\\]</span></p><p><span class="math display">\[\theta = \mathrm{asin}\left(2\,q_0 \,q_2 -2\,q_1 \,q_3\right)\tag{4.2.8}\]</span></p><p><span class="math display">\[\phi = \textrm{atan2}\left(2\,q_0 \,q_1 +2\,q_2 \,q_3 ,-2\,{q_1 }^2-2\,{q_2 }^2 +1\right)\tag{4.2.9}\]</span></p><p><span class="math display">\[\psi = \textrm{atan2}\left(2\,q_0 \,q_3 +2\,q_1 \,q_2 ,-2\,{q_2 }^2-2\,{q_3 }^2 +1\right) \tag{4.2.10}\]</span></p><p>可由单位四元数<spanclass="math inline">\(q_0^2+q_1^2+q_2^2+q_3^2=1\)</span>，变换出<spanclass="math inline">\(q_i^2\)</span>和项的不同形式。</p>]]></content>
    
    
    <categories>
      
      <category>运动学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>坐标系变换，旋转矩阵，四元数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性系统的能控性和能观测性</title>
    <link href="/2024/05/17/%E7%8E%B0%E6%8E%A7%E7%AC%AC%E5%9B%9B%E7%AB%A0/"/>
    <url>/2024/05/17/%E7%8E%B0%E6%8E%A7%E7%AC%AC%E5%9B%9B%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>本文为对线性系统的能控性和能观测性的知识点总结 <span id="more"></span> ##线性系统的能控性和能观测性</p><h3 id="能控性和能观测性的定义">1、能控性和能观测性的定义</h3><p>直观上的理解：</p><p>能控性：指系统内的所有状态是否可以由输入影响</p><p>能观测性：指系统内的所有状态是否可以由输出反映</p><h4 id="mm">1.1 mm</h4><h3 id="线性连续系统的能控性判据">2、线性连续系统的能控性判据</h3><h4id="线性连续时不变系统的能控性判据">2.1、线性连续时不变系统的能控性判据</h4><h5 id="秩判据">(1)秩判据（*）</h5><p>a、秩判据</p><p>对于线性定常系统 <span class="math display">\[\begin{aligned}\dot{x}(t)&amp;=Ax(t)+Bu(t),X(0)=X_0,t\geq0\end{aligned}\]</span> 其完全能控的<strong>充分必要条件</strong>是 <spanclass="math display">\[\begin{aligned}rankQ_c&amp;=rank[B \ AB \ \cdots \A^{n-1}B]\\&amp;=n\end{aligned}\]</span> 其中<span class="math inline">\(n\)</span>是矩阵<spanclass="math inline">\(A\)</span>的维数，<spanclass="math inline">\(Q_c\)</span>是系统的能控性判别阵</p><p>b、改进的能控性秩判据</p><p>（适用于多输入系统，可减少计算）</p><p>对于线性定常系统:</p><p><span class="math inline">\(\dot{x}\)</span>是<spanclass="math inline">\(n\)</span>维状态向量，<spanclass="math inline">\(u\)</span>是<spanclass="math inline">\(p\)</span>维输入向量 <span class="math display">\[\begin{aligned}\dot{x}(t)&amp;=Ax(t)+Bu(t),X(0)=X_0,t\geq0\end{aligned}\]</span> 其完全能控的<strong>充分必要条件</strong>是: <spanclass="math display">\[rankQ_{n-r+1}=rank[B \ AB \ \cdots \ A^{n-r}B]=n\\r=rankB,r\leq p\\\]</span></p><h5 id="phb秩判据">(2)PHB秩判据（*）</h5><p>对于线性定常系统:</p><p><span class="math inline">\(\dot{x}\)</span>是<spanclass="math inline">\(n\)</span>维状态向量，<spanclass="math inline">\(u\)</span>是<spanclass="math inline">\(p\)</span>维输入向量 <span class="math display">\[\begin{aligned}\dot{x}(t)&amp;=Ax(t)+Bu(t),X(0)=X_0,t\geq0\end{aligned}\]</span> 其完全能控的<strong>充分必要条件</strong>是: <spanclass="math display">\[\lambda_{i}(i=1,2,\ldots,n)\\rank[\lambda_{i}I-A \ \\  B]=n,i=1,\ldots,n\]</span> 其中<spanclass="math inline">\(\lambda_i\)</span>代表矩阵<spanclass="math inline">\(A\)</span>的所有特征值</p><p>或等价地表示为： <span class="math display">\[\\rank[SI-A \ \ \ B]=n,\forall s\in C\]</span> 其中<span class="math inline">\(C\)</span>代表复数集</p><h5 id="对角线规范判据">(3)对角线规范判据（*）</h5><p>对于线性定常系统:</p><p><span class="math inline">\(\dot{x}\)</span>是<spanclass="math inline">\(n\)</span>维状态向量，<spanclass="math inline">\(u\)</span>是<spanclass="math inline">\(p\)</span>维输入向量 <span class="math display">\[\begin{aligned}\dot{x}(t)&amp;=Ax(t)+Bu(t),X(0)=X_0,t\geq0\end{aligned}\]</span> 当<strong>矩阵<spanclass="math inline">\(A\)</span>的特征值<spanclass="math inline">\(\lambda_1、\lambda_2、\dots、\lambda_n\)</span>两两相异</strong>时，</p><p>其完全能控的<strong>充分必要条件</strong>是:</p><p>该系统的对角规范型中<spanclass="math inline">\(\overline{B}\)</span>不包含元素为零的行 <spanclass="math display">\[\dot{x}=\begin{bmatrix}    \lambda_{1} &amp; 0 &amp; \dots &amp; 0 \\    0 &amp; \lambda_{2} &amp; \dots &amp; 0 \\    \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\    0 &amp; 0 &amp; \dots &amp; \lambda_{n}\end{bmatrix}\overline{x} + \overline{B}{u}\]</span></p><h5 id="约当规范型判据">(4)约当规范型判据</h5><p>对于线性定常系统:</p><p><span class="math inline">\(\dot{x}\)</span>是<spanclass="math inline">\(n\)</span>维状态向量，<spanclass="math inline">\(u\)</span>是<spanclass="math inline">\(p\)</span>维输入向量 <span class="math display">\[\begin{aligned}\dot{x}(t)&amp;=Ax(t)+Bu(t),X(0)=X_0,t\geq0\end{aligned}\]</span> 当矩阵<spanclass="math inline">\(A\)</span><strong>有重特征值</strong>时，</p><p>其完全能控的<strong>充分必要条件</strong>是:</p><p>由该系统推导出的约当规范型<spanclass="math inline">\(\dot{\hat{x}}=\dot{A}\hat{x(t)}+\hat{B}u\)</span>中，<spanclass="math inline">\(\hat{B}\)</span>中与同一特征值的各约当小块对应的各子块的最后一行组成的矩阵是<strong>行线性无关的</strong>。</p><h4 id="能控性指数">2.2 能控性指数</h4><h3 id="对偶性">4、对偶性</h3><h3id="连续时间线性时不变系统的结构分解">6、连续时间线性时不变系统的结构分解</h3><h4 id="结构分解解释">(1)结构分解解释：</h4>将连续时间线性时不变系统按能控性分解，可分解为: <spanclass="math display">\[\left\{\begin{array}{ccc}        &amp; x_e \ (能控子系统)\\         &amp; x_{\overline{e}} \ (不能控子系统)\end{array} \right.\]</span> 将连续时间线性时不变系统按能观测性分解，可分解为: <spanclass="math display">\[\left\{\begin{array}{ccc}        &amp; x_o \ (能观测子系统)\\         &amp; x_{\overline{o}} \ (不能观测子系统)\end{array} \right.\]</span> 将连续时间线性时不变系统按能控性、能观测性分解，可分解为: $$ {<span class="math display">\[\begin{array}{ccc}        &amp; x_c \ (能控子系统)\{\begin{array}{ccc}        &amp; x_{co} \ (能控能观测子系统)\\         &amp; x_{c \overline{o}} \ (能控不能观测子系统)\end{array}\\  &amp; x_{\overline{c}} \ (不能控子系统)\{\begin{array}{ccc}   &amp; x_{\overline{c}o} \ (不能控能观测系统)\\         &amp; x_{\overline{c} \overline{o}} \ (不能控不能观测子系统)\end{array}\end{array}\]</span><p>. $$</p><h4id="线性定常系统按能控性的结构分解">(2)线性定常系统按能控性的结构分解（*）</h4><h5id="系统按能控性的结构分解的规范表达式">1)系统按能控性的结构分解的规范表达式</h5>对于不完全能控系统，<spanclass="math inline">\(rank(Q_k)=k&gt;n\)</span>，引入线性非奇异变化<spanclass="math inline">\(\overline{x}=Px\)</span>，系统按能控性的结构分解的规范表达式为(将<spanclass="math inline">\(\overline{x}=Px\)</span>代入原状态空间方程化简)：$$ {<span class="math display">\[\begin{array}{ccc}        \begin{bmatrix}    \dot{\overline{x_c}} \\    \dot{\overline{x_{\overline{c}}}}\end{bmatrix}=\begin{bmatrix}    \overline{A_c} &amp;  \overline{A_{12}} \\     0             &amp;  \overline{A_{\overline{c}}}\end{bmatrix}\begin{bmatrix}    {\overline{x_c}} \\    {\overline{x_{\overline{c}}}}\end{bmatrix}+\begin{bmatrix}    {\overline{B_c}} \\    0\end{bmatrix}u\\y=\begin{bmatrix}    \overline{C_C}  &amp; \overline{C_{\overline{c}}}\end{bmatrix}\begin{bmatrix}    {\overline{x_c}} \\    {\overline{x_{\overline{c}}}}\end{bmatrix}\end{array}\]</span><p>. $$ 其中，<span class="math inline">\(\overline{x_c}\)</span>是<spanclass="math inline">\(k\)</span>维能控分状态，<spanclass="math inline">\(\overline{x_{\overline{c}}}\)</span>是<spanclass="math inline">\((n-k)\)</span>维不能控分状态</p><p>有： $$ <span class="math display">\[\begin{equation}\begin{split}\begin{bmatrix}    {\overline{x}_c} \\    {\overline{x}_{\overline{c}}}\end{bmatrix}=\overline{x}=Px\\\overline{A}=PAP^{-1}=\begin{bmatrix}    \overline{A}_c &amp;  \overline{A}_{12} \\     0             &amp;  \overline{A}_{\overline{c}}\end{bmatrix} \\\overline{B}=PB=\begin{bmatrix}    {\overline{B}_c} \\    0\end{bmatrix} \\\overline{C}=CP^{-1}=\begin{bmatrix}    {\overline{C}_c} &amp; {\overline{C}_\overline{c}}\end{bmatrix}\end{split}\end{equation}\]</span> $$</p><h6 id="非奇异变换矩阵p-1的构造方法">非奇异变换矩阵<spanclass="math inline">\(P^{-1}\)</span>的构造方法</h6><ul><li><p>从能控性判别阵<spanclass="math inline">\(Q_c\)</span>里任意选取<spanclass="math inline">\(k\)</span>个线性无关的列向量，记为<spanclass="math inline">\(q_1、q_2、······,q_k\)</span></p></li><li><p>从n维实数空间中任意选取尽可能简单的<spanclass="math inline">\((n-k)\)</span>个列向量，记为<spanclass="math inline">\(q_{k+1}、q_{k+2}、······,q_n\)</span>，使它们和<spanclass="math inline">\(q_1、q_2、······,q_k\)</span>线性无关</p></li><li><p><span class="math display">\[P^{-1} = \begin{bmatrix}    q_1 &amp; q_2 &amp; ······ &amp; q_k &amp; q_{k+1} &amp; q_{k+2}&amp; ······ &amp; q_n\end{bmatrix}\]</span></p></li></ul><h5 id="系统结构能控性分解特点">2)系统结构能控性分解特点</h5><p>a、<spanclass="math inline">\(n\)</span>维不完全能控系统与其能控子系统具有相同的传递函数矩阵<span class="math display">\[\begin{equation}\begin{split}G(s) &amp; = C(sI-A)^{-1}B\\&amp;=\overline{C}(sI-\overline{A})^{-1}\overline{B}\\&amp;=\overline{C}_c(sI_{k}-\overline{A}_c)^{-1}\overline{B}_c\end{split}\end{equation}\]</span> 且有： <span class="math display">\[\begin{equation}\begin{split}rank\begin{bmatrix}    B &amp; AB  &amp;···&amp; A^{n-1}B\end{bmatrix} &amp;=rank\begin{bmatrix}    \overline{B}_c &amp; \overline{A}_c\overline{B}_c  &amp;···&amp;\overline{A}_{c}^{n-1}\overline{B}_c\end{bmatrix}\\&amp;=k\end{split}\end{equation}\]</span> 当从传递特性来分析系统使，可以等价地分析其能控子系统。</p><p>b、由于<spanclass="math inline">\(\overline{A}_\overline{c}\)</span>分别会影响能控子系统状态响应<spanclass="math inline">\(x_c(t)\)</span>，<spanclass="math inline">\(\overline{C}_\overline{c}\)</span>会影响系统输出响应<spanclass="math inline">\(y(t)\)</span>，故要求<spanclass="math inline">\(\overline{A}_\overline{c}\)</span>的所有特征值都必须是稳定的（即所有特征值都具有负实部）</p><p>c、系统的特征多项式分解 <span class="math display">\[\begin{equation}\begin{split}det(sI-A) &amp;= det(sI-\overline{A})\\          &amp;=det\begin{bmatrix}   sI-\overline{A}_c &amp; -\overline{A}_{12}\\   0                 &amp; sI-\overline{A}_{\overline{c}}\end{bmatrix}\\&amp;=det(sI-\overline{A}_c)·det(sI-\overline{A}_{\overline{c}})\end{split}\end{equation}\]</span> 将<spanclass="math inline">\(det(sI-\overline{A}_c)\)</span>称为能控振型、<spanclass="math inline">\(det(sI-\overline{A}_{\overline{c}})\)</span>称为不能控振型；外部输入<spanclass="math inline">\(u\)</span>只能改变能控振型。</p><p>d、构造<spanclass="math inline">\(P^{-1}\)</span>矩阵时，列向量选取不唯一，故能控性分解结果不唯一</p>]]></content>
    
    
    <categories>
      
      <category>控制理论</category>
      
      <category>现代控制理论学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>现代控制理论</tag>
      
      <tag>能控性</tag>
      
      <tag>能观性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微机原理汇编语言程序设计基础知识点总结</title>
    <link href="/2024/05/17/%E7%AC%AC%E4%BA%94%E7%AB%A0%E6%80%BB%E7%BB%93/"/>
    <url>/2024/05/17/%E7%AC%AC%E4%BA%94%E7%AB%A0%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>本文为对微机原理汇编语言部分的知识点总结 <span id="more"></span></p><h2 id="汇编语言概述">1、汇编语言概述</h2><h3 id="汇编语言的三种语句">1.1 汇编语言的三种语句</h3><table><thead><tr class="header"><th>汇编语言的三种语句</th><th>介绍</th></tr></thead><tbody><tr class="odd"><td>指令语句</td><td>可以翻译成机器码</td></tr><tr class="even"><td>伪指令语句</td><td>指示、引导汇编程序在汇编过程中完成某些操作</td></tr><tr class="odd"><td>宏指令语句</td><td>若干条指令语句可用一条宏指令语句代替</td></tr></tbody></table><h3 id="汇编语句的格式">1.2 汇编语句的格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">[名字项]   操作码项   [操作数项]   ;注释项<br></code></pre></td></tr></table></figure><p>各项字段介绍：</p><table><thead><tr class="header"><th>字段</th><th>是否可舍(带[]可根据需要舍去)</th><th>含义</th><th>写法的注意事项</th></tr></thead><tbody><tr class="odd"><td>[名字项]</td><td>可</td><td>一个符号，可以是变量、标号、符号常数、段名、子程序名等</td><td>可大写字母、小写字母、阿拉伯数字、特殊符号，但是<strong>第一个符号必须是字母</strong></td></tr><tr class="even"><td>操作码项</td><td>不可</td><td>各类指令的助记符，表明要执行的操作</td><td></td></tr><tr class="odd"><td>[操作数项]</td><td>可</td><td>对伪指令和宏指令：给出参数。<br />对指令语句：给出常数、寄存器、标号、变量、表达式、类型说明符等等。</td><td>可由一项或多项组成，多个操作数之间用“,”间隔</td></tr><tr class="even"><td>[;注释项]</td><td>可</td><td>用于说明</td><td>一定要用";"隔开</td></tr></tbody></table><h2 id="伪指令语句">2、伪指令语句</h2><p>伪指令语句简介：</p><p>​ 本身不产生相应的机器码，但会指示编译器如何编译</p><h3 id="数据定义语句">2.1 数据定义语句</h3><h4 id="数据定义语句格式">(1)数据定义语句格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">[变量]     助记符   参数表  ;注释<br></code></pre></td></tr></table></figure><h4 id="变量的属性">(2)变量的属性</h4><table><thead><tr class="header"><th>变量的属性</th><th>含义</th><th></th></tr></thead><tbody><tr class="odd"><td>偏移属性</td><td>其偏移地址为16位无符号数，代表从起始地址(0000H)到变量的位置之间的字节数</td><td></td></tr><tr class="even"><td>段属性</td><td>代表变量所表示的偏移地址在哪个段，一般在数据段，若在其它段，可用段前缀或者段定义语句来指明</td><td></td></tr><tr class="odd"><td>类型属性</td><td>代表该语句中每一个参数的长度（单位:字节）</td><td></td></tr></tbody></table><h4 id="数据定义语句中的助记符">(3)数据定义语句中的助记符</h4><table><thead><tr class="header"><th>数据定义语句中的助记符</th><th>功能</th><th>解释</th><th></th></tr></thead><tbody><tr class="odd"><td>DB</td><td>定义字节(Byte)</td><td>代表其后每个操作数都占1Byte</td><td></td></tr><tr class="even"><td>DW</td><td>定义字</td><td>代表其后每个操作数都占1个字，1个字的低8位存在第1个Byte的低地址中，字的高8位存在第2个Byte的高地址中</td><td></td></tr><tr class="odd"><td>DD</td><td>定义双字</td><td>代表其后每个操作数都占两个字</td><td></td></tr><tr class="even"><td>DQ</td><td>定义4字</td><td>代表其后每个操作数都占4个字</td><td></td></tr><tr class="odd"><td>DT</td><td>定义5字</td><td>代表其后每个操作数都占5个字</td><td></td></tr></tbody></table><h4 id="参数表">(4)参数表</h4><p>书写注意：多个参数之间用","隔开，存入存储单元之后，为了便于阅读，在画示意图的时候都应该写成16进制（补码）</p><table><thead><tr class="header"><th>参数的类型</th><th>解释</th><th></th></tr></thead><tbody><tr class="odd"><td>常数或表达式</td><td>汇编时，汇编程序将这些参数的数据存放到相应存储单元</td><td></td></tr><tr class="even"><td>字符串</td><td>字符汇编后应用ASCII码表示，注意区分DB和DW两种定义方式（用DW定义时，写在前8位的是数据的高字节，应该在高地址）</td><td></td></tr><tr class="odd"><td>预留空单元</td><td>写法：用“?”表示</td><td></td></tr><tr class="even"><td>复制操作符DUP</td><td>写法： 数量 DUP(要复制的内容)</td><td></td></tr><tr class="odd"><td>偏移地址(标号、变量)</td><td>将标号或者变量的<strong>偏移地址</strong>装入对应的存储单元</td><td></td></tr></tbody></table><h3 id="符号定义语句等值语句">2.2 符号定义语句(等值语句)</h3><p>符号：汇编语言中所有的变量名、标号名、子程序名、助记符</p><h4 id="符号定义语句的格式">(1)符号定义语句的格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">符号名   EQU   表达式   ;注释<br></code></pre></td></tr></table></figure><h4 id="符号定义语句的作用">(2)符号定义语句的作用</h4><table><thead><tr class="header"><th>可用于下列情况（EQU语句不占用内存单元）</th></tr></thead><tbody><tr class="odd"><td>为常量或表达式定义一个符号名，定义后，涉及该常量或表达式的地方均可用此符号名代替</td></tr><tr class="even"><td>给变量或标量定义一个新的类型名并起一个新名</td></tr><tr class="odd"><td>给地址表达式指出的任意存储单元定义一个名字</td></tr></tbody></table><table><thead><tr class="header"><th>与“=”指令的区别</th></tr></thead><tbody><tr class="odd"><td>EQU伪指令中的符号名在同一程序中不允许重复定义</td></tr><tr class="even"><td>“=”伪指令允许符号重复定义</td></tr></tbody></table><h3 id="段定义语句">2.2 段定义语句</h3><p>一共三类，分别是分段伪指令、设定伪指令、开始伪指令</p><h4 id="分段伪指令">(1)分段伪指令</h4><h5 id="a-分段伪指令格式">a 分段伪指令格式：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">段名   SEGMENT   [定位类型]  [组合类型]  [‘类别’]<br><br>······<br><br>··· (汇编语句)<br><br>······<br><br>段名   ENDS<br></code></pre></td></tr></table></figure><h5 id="b-分段伪指令格式的解释和注意事项">b分段伪指令格式的解释和注意事项</h5><table><thead><tr class="header"><th>对应部分</th><th>是否可省略</th><th>解释和注意事项</th></tr></thead><tbody><tr class="odd"><td>段名</td><td>不可省略</td><td>同一段的段名要一致</td></tr><tr class="even"><td>SEGMENT、ENDS</td><td>不可省略，要成对出现</td><td>其中间是段体，由汇编语句组成</td></tr><tr class="odd"><td>[定位类型]</td><td>可选</td><td>有四种类型（若省略了该项，则隐含为PARA）：<br />PARA：<br />(1)指定段的起始地址必须从小段边界开始；<br />(2)地址的最低4位必须是0。<br />BYTE：<br />指定段的起始地址可以从任何地址开始。<br />WORD：<br />(1)指定段的起始地址从字的边界开始；<br />(2)段地址必须是偶数；<br />(3)地址的最低位必为0<br />PAGE：<br />(1)指定段的起始地址从页的边界开始；<br />(2)地址的最低8位必须是0</td></tr><tr class="even"><td>[组合类型]</td><td>可选</td><td>一共6种(若省略该项，则隐含为NONE)<br />NONE：<br />表示该段在连接时与其它段在逻辑上不发生任何关系。<br />PUBLIC:<br />表示该段与其他段中用PUBLIC说明的同名同类型的段连接成一个逻辑段<br />STACK：<br />表示连接时将具有STACK类型的同名段连接成一个大堆栈，由各模块共享<br />COMMON：<br />表示连接时与其他同名段有相同的起始地址，连接长度是各段中最大长度<br />MEMORY：<br />表示该段在连接时，被放在所有段的最后(高地址段)<br />AT表达式：<br />表达式计算出来的16位值为该段的起始地址</td></tr><tr class="odd"><td>['类别']</td><td>可选</td><td>单引号括起来的字符串，表示该段的类别，在连接时只与同类别的段发生关联</td></tr></tbody></table><h4 id="设定伪指令">(2)设定伪指令</h4><h5 id="a-设定伪指令格式">a 设定伪指令格式</h5><p>一般在代码段的最前面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">ASSUME   段寄存器:段名,段寄存器:段名······<br></code></pre></td></tr></table></figure><h5 id="b-设定伪指令功能">b 设定伪指令功能</h5><p>规定段属性，即指出段寄存器CS、DS、ES、SS被设定为内存中哪一段的段寄存器</p><h5 id="c-注意事项">c 注意事项</h5><p>使用之后，还需使用MOV指令为DS、ES、SS段寄存器赋值(CS段寄存器不能赋值，因为它是系统初始化时自动设置的)</p><p>例如：假设DATA是一个数据段的段名，为DS寄存器赋值的代码示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">MOV AX,DATA<br>MOV DX,AX<br></code></pre></td></tr></table></figure><h4 id="开始伪指令">（3）开始伪指令</h4><h5 id="a-开始伪指令的格式">a 开始伪指令的格式</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">ORG   表达式<br></code></pre></td></tr></table></figure><h5 id="b-开始伪指令的格式">b 开始伪指令的格式</h5><p>用于指出其后的程序段或数据段存放起始数据的偏移地址</p><h4 id="符号">(4)符号$</h4><p>表示地址计数器的当前值</p><h3 id="过程定义语句">2.4 过程定义语句</h3><p>过程也称子程序，过程被定义后可以用CALL指令调用</p><h4 id="过程定义语句的格式">(1)过程定义语句的格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">过程名   PROC   类型<br>         ···<br>         ···<br>         RET<br>过程名   ENDP<br></code></pre></td></tr></table></figure><h4 id="过程类型介绍">(2)过程类型介绍</h4><table><thead><tr class="header"><th>类型属性</th><th>作用</th><th>注意事项</th></tr></thead><tbody><tr class="odd"><td>NEAR</td><td>指出过程是段内调用</td><td>若不指定属性，默认为NEAR</td></tr><tr class="even"><td>FAR</td><td>指出过程是段间调用</td><td>过程被定义为FAR，必须使用段间调用指令</td></tr></tbody></table><h3 id="程序开始结束语句">2.5 程序开始、结束语句</h3><h4 id="程序开始语句">(1)程序开始语句</h4><h5 id="a-在程序的开始用name命名">a 在程序的开始用NAME命名</h5><p>汇编程序用模块名作为程序名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">NAME   模块名<br></code></pre></td></tr></table></figure><h5 id="b-在程序的开始用title命名">b 在程序的开始用TITLE命名</h5><p>汇编程序用标题的前6个字符作为程序名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">TITLE   标题<br></code></pre></td></tr></table></figure><h5 id="c-汇编程序也允许源程序不用name或title命名">c汇编程序也允许源程序不用NAME或TITLE命名</h5><h4 id="程序结束语句">(2) 程序结束语句</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">END   标号(源程序中第一条指令语句前的标号)<br></code></pre></td></tr></table></figure><h2 id="指令语句">3、指令语句</h2><h3 id="指令语句格式">3.1 指令语句格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">[标号:]   指令助记符   [操作数]   ;注释<br></code></pre></td></tr></table></figure><p>带[]的和注释是任选项，若写了标号，那其后的":"不可省略！</p><h3 id="指令语句的标号">3.2 指令语句的标号</h3><p>标号是给某条指令起的名字</p><h4 id="属性">(1)属性</h4><table><thead><tr class="header"><th>属性</th><th>含义</th><th></th></tr></thead><tbody><tr class="odd"><td>段属性</td><td>定义标号所在段的段地址，标号所在段的段地址只能在CS寄存器中</td><td></td></tr><tr class="even"><td>偏移属性</td><td>是一个16位无符号数，代表从起始地址到标号位置间的字节数</td><td></td></tr><tr class="odd"><td>类型属性</td><td>NEAR属性：转移或调用指令与标号所指语句或过程在同一代码段内，转移或调用时只需改变IP值，不改变CS值<br />FAR属性：转移或调用指令与标号所指语句或过程不在同一代码段内；转移或调用时，IP值、CS值都改变</td><td></td></tr></tbody></table><h4 id="标号的使用">(2) 标号的使用</h4><table style="width:100%;"><thead><tr class="header"><th>使用情况</th><th></th><th></th></tr></thead><tbody><tr class="odd"><td>无条件转移指令、调用指令</td><td>段间转移或调用：使用FAR<br />段内转移或调用：使用NEAR（指令距离在-32768<sub>+32767之间都可），或者是FAR<br />段内短转移：在指令的标号前加SHORT（指令距离在-128</sub>+127之间）</td><td></td></tr><tr class="even"><td>条件转移指令或循环转移指令</td><td>只能SHORT(可省略)</td><td></td></tr></tbody></table><h2 id="汇编语言程序设计">4、汇编语言程序设计</h2><h3 id="dos功能及调用">4.5 DOS功能及调用</h3><h4 id="常用的dos系统功能调用">常用的DOS系统功能调用</h4><h5 id="ch终止程序返回dos">(1) 4CH——终止程序，返回DOS</h5><p>程序段如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">MOV AH,4CH<br>INT 21H<br></code></pre></td></tr></table></figure><h5 id="h读取键盘字符使回显">(2) 01H——读取键盘字符使回显</h5><p>程序段如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">MOV AH,01H<br>INT 21H<br></code></pre></td></tr></table></figure><p>扫描键盘，等待按键。</p><p>将按键对应的ASCII码送入AL寄存器，同时显示器显示该字符。</p><h5 id="h控制台输入但不回显">(3) 07H——控制台输入但不回显</h5><p>程序段如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">MOV AH,07H<br>INT 21H<br></code></pre></td></tr></table></figure><h5 id="ah字符串输入">(4) 0AH——字符串输入</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">MOV AH,0AH<br>···DS:DX&lt;-从键盘接收字符的输入缓冲区首址···<br>INT 21H<br></code></pre></td></tr></table></figure><h5 id="h显示器显示字符">(5)02H——显示器显示字符</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">MOV AH,02H<br>MOV DL,要显示字符的ASCII码<br>INT 21H<br></code></pre></td></tr></table></figure><h5 id="h打印机打印字符">(6)05H——打印机打印字符</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">MOV AH,05H<br>MOV DL,要显示字符的ASCII码<br>INT 21H<br></code></pre></td></tr></table></figure><h5 id="h显示器显示字符串">(7)09H——显示器显示字符串</h5><p>该字符串必须在数据段内，且以'$'为结束标志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">MOV AH,09H<br>MOV DX,要显示字符串的首地址<br>INT 21H<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编语言，微机原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/05/17/hello-world/"/>
    <url>/2024/05/17/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
